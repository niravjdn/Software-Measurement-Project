<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2.io</a> &gt; <span class="el_source">FileHandler.java</span></div><h1>FileHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.configuration2.io;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicReference;

import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.configuration2.io.FileLocator.FileLocatorBuilder;
import org.apache.commons.configuration2.sync.LockMode;
import org.apache.commons.configuration2.sync.NoOpSynchronizer;
import org.apache.commons.configuration2.sync.Synchronizer;
import org.apache.commons.configuration2.sync.SynchronizerSupport;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;p&gt;
 * A class that manages persistence of an associated {@link FileBased} object.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Instances of this class can be used to load and save arbitrary objects
 * implementing the {@code FileBased} interface in a convenient way from and to
 * various locations. At construction time the {@code FileBased} object to
 * manage is passed in. Basically, this object is assigned a location from which
 * it is loaded and to which it can be saved. The following possibilities exist
 * to specify such a location:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;URLs: With the method {@code setURL()} a full URL to the configuration
 * source can be specified. This is the most flexible way. Note that the
 * {@code save()} methods support only &lt;em&gt;file:&lt;/em&gt; URLs.&lt;/li&gt;
 * &lt;li&gt;Files: The {@code setFile()} method allows to specify the configuration
 * source as a file. This can be either a relative or an absolute file. In the
 * former case the file is resolved based on the current directory.&lt;/li&gt;
 * &lt;li&gt;As file paths in string form: With the {@code setPath()} method a full
 * path to a configuration file can be provided as a string.&lt;/li&gt;
 * &lt;li&gt;Separated as base path and file name: The base path is a string defining
 * either a local directory or a URL. It can be set using the
 * {@code setBasePath()} method. The file name, non surprisingly, defines the
 * name of the configuration file.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * An instance stores a location. The {@code load()} and {@code save()} methods
 * that do not take an argument make use of this internal location.
 * Alternatively, it is also possible to use overloaded variants of
 * {@code load()} and {@code save()} which expect a location. In these cases the
 * location specified takes precedence over the internal one; the internal
 * location is not changed.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The actual position of the file to be loaded is determined by a
 * {@link FileLocationStrategy} based on the location information that has been
 * provided. By providing a custom location strategy the algorithm for searching
 * files can be adapted. Save operations require more explicit information. They
 * cannot rely on a location strategy because the file to be written may not yet
 * exist. So there may be some differences in the way location information is
 * interpreted by load and save operations. In order to avoid this, the
 * following approach is recommended:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Use the desired {@code setXXX()} methods to define the location of the
 * file to be loaded.&lt;/li&gt;
 * &lt;li&gt;Call the {@code locate()} method. This method resolves the referenced
 * file (if possible) and fills out all supported location information.&lt;/li&gt;
 * &lt;li&gt;Later on, {@code save()} can be called. This method now has sufficient
 * information to store the file at the correct location.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * When loading or saving a {@code FileBased} object some additional
 * functionality is performed if the object implements one of the following
 * interfaces:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@code FileLocatorAware}: In this case an object with the current file
 * location is injected before the load or save operation is executed. This is
 * useful for {@code FileBased} objects that depend on their current location,
 * e.g. to resolve relative path names.&lt;/li&gt;
 * &lt;li&gt;{@code SynchronizerSupport}: If this interface is implemented, load and
 * save operations obtain a write lock on the {@code FileBased} object before
 * they access it. (In case of a save operation, a read lock would probably be
 * sufficient, but because of the possible injection of a {@link FileLocator}
 * object it is not allowed to perform multiple save operations in parallel;
 * therefore, by obtaining a write lock, we are on the safe side.)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * This class is thread-safe.
 * &lt;/p&gt;
 *
 * @version $Id$
 * @since 2.0
 */
public class FileHandler
{
    /** Constant for the URI scheme for files. */
    private static final String FILE_SCHEME = &quot;file:&quot;;

    /** Constant for the URI scheme for files with slashes. */
    private static final String FILE_SCHEME_SLASH = FILE_SCHEME + &quot;//&quot;;

    /**
     * A dummy implementation of {@code SynchronizerSupport}. This object is
     * used when the file handler's content does not implement the
     * {@code SynchronizerSupport} interface. All methods are just empty dummy
     * implementations.
     */
<span class="fc" id="L134">    private static final SynchronizerSupport DUMMY_SYNC_SUPPORT =</span>
            new SynchronizerSupport()
<span class="fc" id="L136">            {</span>
                @Override
                public void unlock(final LockMode mode)
                {
<span class="fc" id="L140">                }</span>

                @Override
                public void setSynchronizer(final Synchronizer sync)
                {
<span class="nc" id="L145">                }</span>

                @Override
                public void lock(final LockMode mode)
                {
<span class="fc" id="L150">                }</span>

                @Override
                public Synchronizer getSynchronizer()
                {
<span class="nc" id="L155">                    return NoOpSynchronizer.INSTANCE;</span>
                }
            };

    /** The file-based object managed by this handler. */
    private final FileBased content;

    /** A reference to the current {@code FileLocator} object. */
    private final AtomicReference&lt;FileLocator&gt; fileLocator;

    /** A collection with the registered listeners. */
<span class="fc" id="L166">    private final List&lt;FileHandlerListener&gt; listeners =</span>
            new CopyOnWriteArrayList&lt;&gt;();

    /**
     * Creates a new instance of {@code FileHandler} which is not associated
     * with a {@code FileBased} object and thus does not have a content. Objects
     * of this kind can be used to define a file location, but it is not
     * possible to actually load or save data.
     */
    public FileHandler()
    {
<span class="fc" id="L177">        this(null);</span>
<span class="fc" id="L178">    }</span>

    /**
     * Creates a new instance of {@code FileHandler} and sets the managed
     * {@code FileBased} object.
     *
     * @param obj the file-based object to manage
     */
    public FileHandler(final FileBased obj)
    {
<span class="fc" id="L188">        this(obj, emptyFileLocator());</span>
<span class="fc" id="L189">    }</span>

    /**
     * Creates a new instance of {@code FileHandler} which is associated with
     * the given {@code FileBased} object and the location defined for the given
     * {@code FileHandler} object. A copy of the location of the given
     * {@code FileHandler} is created. This constructor is a possibility to
     * associate a file location with a {@code FileBased} object.
     *
     * @param obj the {@code FileBased} object to manage
     * @param c the {@code FileHandler} from which to copy the location (must
     *        not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the {@code FileHandler} is
     *         &lt;b&gt;null&lt;/b&gt;
     */
    public FileHandler(final FileBased obj, final FileHandler c)
    {
<span class="fc" id="L206">        this(obj, checkSourceHandler(c).getFileLocator());</span>
<span class="fc" id="L207">    }</span>

    /**
     * Creates a new instance of {@code FileHandler} based on the given
     * {@code FileBased} and {@code FileLocator} objects.
     *
     * @param obj the {@code FileBased} object to manage
     * @param locator the {@code FileLocator}
     */
    private FileHandler(final FileBased obj, final FileLocator locator)
<span class="fc" id="L217">    {</span>
<span class="fc" id="L218">        content = obj;</span>
<span class="fc" id="L219">        fileLocator = new AtomicReference&lt;&gt;(locator);</span>
<span class="fc" id="L220">    }</span>

    /**
     * Creates a new {@code FileHandler} instance from properties stored in a
     * map. This method tries to extract a {@link FileLocator} from the map. A
     * new {@code FileHandler} is created based on this {@code FileLocator}.
     *
     * @param map the map (may be &lt;b&gt;null&lt;/b&gt;)
     * @return the newly created {@code FileHandler}
     * @see FileLocatorUtils#fromMap(Map)
     */
    public static FileHandler fromMap(final Map&lt;String, ?&gt; map)
    {
<span class="fc" id="L233">        return new FileHandler(null, FileLocatorUtils.fromMap(map));</span>
    }

    /**
     * Returns the {@code FileBased} object associated with this
     * {@code FileHandler}.
     *
     * @return the associated {@code FileBased} object
     */
    public final FileBased getContent()
    {
<span class="fc" id="L244">        return content;</span>
    }

    /**
     * Adds a listener to this {@code FileHandler}. It is notified about
     * property changes and IO operations.
     *
     * @param l the listener to be added (must not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the listener is &lt;b&gt;null&lt;/b&gt;
     */
    public void addFileHandlerListener(final FileHandlerListener l)
    {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (l == null)</span>
        {
<span class="fc" id="L258">            throw new IllegalArgumentException(&quot;Listener must not be null!&quot;);</span>
        }
<span class="fc" id="L260">        listeners.add(l);</span>
<span class="fc" id="L261">    }</span>

    /**
     * Removes the specified listener from this object.
     *
     * @param l the listener to be removed
     */
    public void removeFileHandlerListener(final FileHandlerListener l)
    {
<span class="fc" id="L270">        listeners.remove(l);</span>
<span class="fc" id="L271">    }</span>

    /**
     * Return the name of the file. If only a URL is defined, the file name
     * is derived from there.
     *
     * @return the file name
     */
    public String getFileName()
    {
<span class="fc" id="L281">        final FileLocator locator = getFileLocator();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (locator.getFileName() != null)</span>
        {
<span class="fc" id="L284">            return locator.getFileName();</span>
        }

<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (locator.getSourceURL() != null)</span>
        {
<span class="fc" id="L289">            return FileLocatorUtils.getFileName(locator.getSourceURL());</span>
        }

<span class="fc" id="L292">        return null;</span>
    }

    /**
     * Set the name of the file. The passed in file name can contain a relative
     * path. It must be used when referring files with relative paths from
     * classpath. Use {@code setPath()} to set a full qualified file name. The
     * URL is set to &lt;b&gt;null&lt;/b&gt; as it has to be determined anew based on the
     * file name and the base path.
     *
     * @param fileName the name of the file
     */
    public void setFileName(final String fileName)
    {
<span class="fc" id="L306">        final String name = normalizeFileURL(fileName);</span>
<span class="fc" id="L307">        new Updater()</span>
<span class="fc" id="L308">        {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder)
            {
<span class="fc" id="L312">                builder.fileName(name);</span>
<span class="fc" id="L313">                builder.sourceURL(null);</span>
<span class="fc" id="L314">            }</span>
        }
<span class="fc" id="L316">        .update();</span>
<span class="fc" id="L317">    }</span>

    /**
     * Return the base path. If no base path is defined, but a URL, the base
     * path is derived from there.
     *
     * @return the base path
     */
    public String getBasePath()
    {
<span class="fc" id="L327">        final FileLocator locator = getFileLocator();</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (locator.getBasePath() != null)</span>
        {
<span class="fc" id="L330">            return locator.getBasePath();</span>
        }

<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (locator.getSourceURL() != null)</span>
        {
<span class="fc" id="L335">            return FileLocatorUtils.getBasePath(locator.getSourceURL());</span>
        }

<span class="fc" id="L338">        return null;</span>
    }

    /**
     * Sets the base path. The base path is typically either a path to a
     * directory or a URL. Together with the value passed to the
     * {@code setFileName()} method it defines the location of the configuration
     * file to be loaded. The strategies for locating the file are quite
     * tolerant. For instance if the file name is already an absolute path or a
     * fully defined URL, the base path will be ignored. The base path can also
     * be a URL, in which case the file name is interpreted in this URL's
     * context. If other methods are used for determining the location of the
     * associated file (e.g. {@code setFile()} or {@code setURL()}), the base
     * path is automatically set. Setting the base path using this method
     * automatically sets the URL to &lt;b&gt;null&lt;/b&gt; because it has to be
     * determined anew based on the file name and the base path.
     *
     * @param basePath the base path.
     */
    public void setBasePath(final String basePath)
    {
<span class="fc" id="L359">        final String path = normalizeFileURL(basePath);</span>
<span class="fc" id="L360">        new Updater()</span>
<span class="fc" id="L361">        {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder)
            {
<span class="fc" id="L365">                builder.basePath(path);</span>
<span class="fc" id="L366">                builder.sourceURL(null);</span>
<span class="fc" id="L367">            }</span>
        }
<span class="fc" id="L369">        .update();</span>
<span class="fc" id="L370">    }</span>

    /**
     * Returns the location of the associated file as a {@code File} object. If
     * the base path is a URL with a protocol different than &amp;quot;file&amp;quot;,
     * or the file is within a compressed archive, the return value will not
     * point to a valid file object.
     *
     * @return the location as {@code File} object; this can be &lt;b&gt;null&lt;/b&gt;
     */
    public File getFile()
    {
<span class="fc" id="L382">        return createFile(getFileLocator());</span>
    }

    /**
     * Sets the location of the associated file as a {@code File} object. The
     * passed in {@code File} is made absolute if it is not yet. Then the file's
     * path component becomes the base path and its name component becomes the
     * file name.
     *
     * @param file the location of the associated file
     */
    public void setFile(final File file)
    {
<span class="fc" id="L395">        final String fileName = file.getName();</span>
<span class="fc" id="L396">        final String basePath =</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                (file.getParentFile() != null) ? file.getParentFile()</span>
<span class="fc" id="L398">                        .getAbsolutePath() : null;</span>
<span class="fc" id="L399">        new Updater()</span>
<span class="fc" id="L400">        {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder)
            {
<span class="fc" id="L404">                builder.fileName(fileName).basePath(basePath).sourceURL(null);</span>
<span class="fc" id="L405">            }</span>
        }
<span class="fc" id="L407">        .update();</span>
<span class="fc" id="L408">    }</span>

    /**
     * Returns the full path to the associated file. The return value is a valid
     * {@code File} path only if this location is based on a file on the local
     * disk. If the file was loaded from a packed archive, the returned value is
     * the string form of the URL from which the file was loaded.
     *
     * @return the full path to the associated file
     */
    public String getPath()
    {
<span class="fc" id="L420">        final FileLocator locator = getFileLocator();</span>
<span class="fc" id="L421">        final File file = createFile(locator);</span>
<span class="fc" id="L422">        return FileLocatorUtils.obtainFileSystem(locator).getPath(file,</span>
<span class="fc" id="L423">                locator.getSourceURL(), locator.getBasePath(), locator.getFileName());</span>
    }

    /**
     * Sets the location of the associated file as a full or relative path name.
     * The passed in path should represent a valid file name on the file system.
     * It must not be used to specify relative paths for files that exist in
     * classpath, either plain file system or compressed archive, because this
     * method expands any relative path to an absolute one which may end in an
     * invalid absolute path for classpath references.
     *
     * @param path the full path name of the associated file
     */
    public void setPath(final String path)
    {
<span class="fc" id="L438">        setFile(new File(path));</span>
<span class="fc" id="L439">    }</span>

    /**
     * Returns the location of the associated file as a URL. If a URL is set,
     * it is directly returned. Otherwise, an attempt to locate the referenced
     * file is made.
     *
     * @return a URL to the associated file; can be &lt;b&gt;null&lt;/b&gt; if the location
     *         is unspecified
     */
    public URL getURL()
    {
<span class="fc" id="L451">        final FileLocator locator = getFileLocator();</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">        return (locator.getSourceURL() != null) ? locator.getSourceURL()</span>
<span class="fc" id="L453">                : FileLocatorUtils.locate(locator);</span>
    }

    /**
     * Sets the location of the associated file as a URL. For loading this can
     * be an arbitrary URL with a supported protocol. If the file is to be
     * saved, too, a URL with the &amp;quot;file&amp;quot; protocol should be provided.
     * This method sets the file name and the base path to &lt;b&gt;null&lt;/b&gt;.
     * They have to be determined anew based on the new URL.
     *
     * @param url the location of the file as URL
     */
    public void setURL(final URL url)
    {
<span class="fc" id="L467">        new Updater()</span>
<span class="fc" id="L468">        {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder)
            {
<span class="fc" id="L472">                builder.sourceURL(url);</span>
<span class="fc" id="L473">                builder.basePath(null).fileName(null);</span>
<span class="fc" id="L474">            }</span>
        }
<span class="fc" id="L476">        .update();</span>
<span class="fc" id="L477">    }</span>

    /**
     * Returns a {@code FileLocator} object with the specification of the file
     * stored by this {@code FileHandler}. Note that this method returns the
     * internal data managed by this {@code FileHandler} as it was defined.
     * This is not necessarily the same as the data returned by the single
     * access methods like {@code getFileName()} or {@code getURL()}: These
     * methods try to derive missing data from other values that have been set.
     *
     * @return a {@code FileLocator} with the referenced file
     */
    public FileLocator getFileLocator()
    {
<span class="fc" id="L491">        return fileLocator.get();</span>
    }

    /**
     * Sets the file to be accessed by this {@code FileHandler} as a
     * {@code FileLocator} object.
     *
     * @param locator the {@code FileLocator} with the definition of the file to
     *        be accessed (must not be &lt;b&gt;null&lt;/b&gt;
     * @throws IllegalArgumentException if the {@code FileLocator} is
     *         &lt;b&gt;null&lt;/b&gt;
     */
    public void setFileLocator(final FileLocator locator)
    {
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (locator == null)</span>
        {
<span class="fc" id="L507">            throw new IllegalArgumentException(&quot;FileLocator must not be null!&quot;);</span>
        }

<span class="fc" id="L510">        fileLocator.set(locator);</span>
<span class="fc" id="L511">        fireLocationChangedEvent();</span>
<span class="fc" id="L512">    }</span>

    /**
     * Tests whether a location is defined for this {@code FileHandler}.
     *
     * @return &lt;b&gt;true&lt;/b&gt; if a location is defined, &lt;b&gt;false&lt;/b&gt; otherwise
     */
    public boolean isLocationDefined()
    {
<span class="fc" id="L521">        return FileLocatorUtils.isLocationDefined(getFileLocator());</span>
    }

    /**
     * Clears the location of this {@code FileHandler}. Afterwards this handler
     * does not point to any valid file.
     */
    public void clearLocation()
    {
<span class="fc" id="L530">        new Updater()</span>
<span class="fc" id="L531">        {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder)
            {
<span class="fc" id="L535">                builder.basePath(null).fileName(null).sourceURL(null);</span>
<span class="fc" id="L536">            }</span>
        }
<span class="fc" id="L538">        .update();</span>
<span class="fc" id="L539">    }</span>

    /**
     * Returns the encoding of the associated file. Result can be &lt;b&gt;null&lt;/b&gt; if
     * no encoding has been set.
     *
     * @return the encoding of the associated file
     */
    public String getEncoding()
    {
<span class="fc" id="L549">        return getFileLocator().getEncoding();</span>
    }

    /**
     * Sets the encoding of the associated file. The encoding applies if binary
     * files are loaded. Note that in this case setting an encoding is
     * recommended; otherwise the platform's default encoding is used.
     *
     * @param encoding the encoding of the associated file
     */
    public void setEncoding(final String encoding)
    {
<span class="fc" id="L561">        new Updater()</span>
<span class="fc" id="L562">        {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder)
            {
<span class="fc" id="L566">                builder.encoding(encoding);</span>
<span class="fc" id="L567">            }</span>
        }
<span class="fc" id="L569">        .update();</span>
<span class="fc" id="L570">    }</span>

    /**
     * Returns the {@code FileSystem} to be used by this object when locating
     * files. Result is never &lt;b&gt;null&lt;/b&gt;; if no file system has been set, the
     * default file system is returned.
     *
     * @return the used {@code FileSystem}
     */
    public FileSystem getFileSystem()
    {
<span class="fc" id="L581">        return FileLocatorUtils.obtainFileSystem(getFileLocator());</span>
    }

    /**
     * Sets the {@code FileSystem} to be used by this object when locating
     * files. If a &lt;b&gt;null&lt;/b&gt; value is passed in, the file system is reset to
     * the default file system.
     *
     * @param fileSystem the {@code FileSystem}
     */
    public void setFileSystem(final FileSystem fileSystem)
    {
<span class="fc" id="L593">        new Updater()</span>
<span class="fc" id="L594">        {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder)
            {
<span class="fc" id="L598">                builder.fileSystem(fileSystem);</span>
<span class="fc" id="L599">            }</span>
        }
<span class="fc" id="L601">        .update();</span>
<span class="fc" id="L602">    }</span>

    /**
     * Resets the {@code FileSystem} used by this object. It is set to the
     * default file system.
     */
    public void resetFileSystem()
    {
<span class="fc" id="L610">        setFileSystem(null);</span>
<span class="fc" id="L611">    }</span>

    /**
     * Returns the {@code FileLocationStrategy} to be applied when accessing the
     * associated file. This method never returns &lt;b&gt;null&lt;/b&gt;. If a
     * {@code FileLocationStrategy} has been set, it is returned. Otherwise,
     * result is the default {@code FileLocationStrategy}.
     *
     * @return the {@code FileLocationStrategy} to be used
     */
    public FileLocationStrategy getLocationStrategy()
    {
<span class="fc" id="L623">        return FileLocatorUtils.obtainLocationStrategy(getFileLocator());</span>
    }

    /**
     * Sets the {@code FileLocationStrategy} to be applied when accessing the
     * associated file. The strategy is stored in the underlying
     * {@link FileLocator}. The argument can be &lt;b&gt;null&lt;/b&gt;; this causes the
     * default {@code FileLocationStrategy} to be used.
     *
     * @param strategy the {@code FileLocationStrategy}
     * @see FileLocatorUtils#DEFAULT_LOCATION_STRATEGY
     */
    public void setLocationStrategy(final FileLocationStrategy strategy)
    {
<span class="fc" id="L637">        new Updater()</span>
<span class="fc" id="L638">        {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder)
            {
<span class="fc" id="L642">                builder.locationStrategy(strategy);</span>
<span class="fc" id="L643">            }</span>

        }
<span class="fc" id="L646">        .update();</span>
<span class="fc" id="L647">    }</span>

    /**
     * Locates the referenced file if necessary and ensures that the associated
     * {@link FileLocator} is fully initialized. When accessing the referenced
     * file the information stored in the associated {@code FileLocator} is
     * used. If this information is incomplete (e.g. only the file name is set),
     * an attempt to locate the file may have to be performed on each access. By
     * calling this method such an attempt is performed once, and the results of
     * a successful localization are stored. Hence, later access to the
     * referenced file can be more efficient. Also, all properties pointing to
     * the referenced file in this object's {@code FileLocator} are set (i.e.
     * the URL, the base path, and the file name). If the referenced file cannot
     * be located, result is &lt;b&gt;false&lt;/b&gt;. This means that the information in
     * the current {@code FileLocator} is insufficient or wrong. If the
     * {@code FileLocator} is already fully defined, it is not changed.
     *
     * @return a flag whether the referenced file could be located successfully
     * @see FileLocatorUtils#fullyInitializedLocator(FileLocator)
     */
    public boolean locate()
    {
        boolean result;
        boolean done;

        do
        {
<span class="fc" id="L674">            final FileLocator locator = getFileLocator();</span>
<span class="fc" id="L675">            FileLocator fullLocator =</span>
<span class="fc" id="L676">                    FileLocatorUtils.fullyInitializedLocator(locator);</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">            if (fullLocator == null)</span>
            {
<span class="fc" id="L679">                result = false;</span>
<span class="fc" id="L680">                fullLocator = locator;</span>
            }
            else
            {
<span class="fc bfc" id="L684" title="All 2 branches covered.">                result =</span>
                        fullLocator != locator
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">                                || FileLocatorUtils.isFullyInitialized(locator);</span>
            }
<span class="fc" id="L688">            done = fileLocator.compareAndSet(locator, fullLocator);</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        } while (!done);</span>

<span class="fc" id="L691">        return result;</span>
    }

    /**
     * Loads the associated file from the underlying location. If no location
     * has been set, an exception is thrown.
     *
     * @throws ConfigurationException if loading of the configuration fails
     */
    public void load() throws ConfigurationException
    {
<span class="fc" id="L702">        load(checkContentAndGetLocator());</span>
<span class="fc" id="L703">    }</span>

    /**
     * Loads the associated file from the given file name. The file name is
     * interpreted in the context of the already set location (e.g. if it is a
     * relative file name, a base path is applied if available). The underlying
     * location is not changed.
     *
     * @param fileName the name of the file to be loaded
     * @throws ConfigurationException if an error occurs
     */
    public void load(final String fileName) throws ConfigurationException
    {
<span class="fc" id="L716">        load(fileName, checkContentAndGetLocator());</span>
<span class="fc" id="L717">    }</span>

    /**
     * Loads the associated file from the specified {@code File}.
     *
     * @param file the file to load
     * @throws ConfigurationException if an error occurs
     */
    public void load(final File file) throws ConfigurationException
    {
        URL url;
        try
        {
<span class="fc" id="L730">            url = FileLocatorUtils.toURL(file);</span>
        }
<span class="nc" id="L732">        catch (final MalformedURLException e1)</span>
        {
<span class="nc" id="L734">            throw new ConfigurationException(&quot;Cannot create URL from file &quot;</span>
                    + file);
<span class="fc" id="L736">        }</span>

<span class="fc" id="L738">        load(url);</span>
<span class="fc" id="L739">    }</span>

    /**
     * Loads the associated file from the specified URL. The location stored in
     * this object is not changed.
     *
     * @param url the URL of the file to be loaded
     * @throws ConfigurationException if an error occurs
     */
    public void load(final URL url) throws ConfigurationException
    {
<span class="fc" id="L750">        load(url, checkContentAndGetLocator());</span>
<span class="fc" id="L751">    }</span>

    /**
     * Loads the associated file from the specified stream, using the encoding
     * returned by {@link #getEncoding()}.
     *
     * @param in the input stream
     * @throws ConfigurationException if an error occurs during the load
     *         operation
     */
    public void load(final InputStream in) throws ConfigurationException
    {
<span class="fc" id="L763">        load(in, checkContentAndGetLocator());</span>
<span class="fc" id="L764">    }</span>

    /**
     * Loads the associated file from the specified stream, using the specified
     * encoding. If the encoding is &lt;b&gt;null&lt;/b&gt;, the default encoding is used.
     *
     * @param in the input stream
     * @param encoding the encoding used, {@code null} to use the default
     *        encoding
     * @throws ConfigurationException if an error occurs during the load
     *         operation
     */
    public void load(final InputStream in, final String encoding)
            throws ConfigurationException
    {
<span class="fc" id="L779">        loadFromStream(in, encoding, null);</span>
<span class="fc" id="L780">    }</span>

    /**
     * Loads the associated file from the specified reader.
     *
     * @param in the reader
     * @throws ConfigurationException if an error occurs during the load
     *         operation
     */
    public void load(final Reader in) throws ConfigurationException
    {
<span class="fc" id="L791">        checkContent();</span>
<span class="fc" id="L792">        injectNullFileLocator();</span>
<span class="fc" id="L793">        loadFromReader(in);</span>
<span class="fc" id="L794">    }</span>

    /**
     * Saves the associated file to the current location set for this object.
     * Before this method can be called a valid location must have been set.
     *
     * @throws ConfigurationException if an error occurs or no location has been
     *         set yet
     */
    public void save() throws ConfigurationException
    {
<span class="fc" id="L805">        save(checkContentAndGetLocator());</span>
<span class="fc" id="L806">    }</span>

    /**
     * Saves the associated file to the specified file name. This does not
     * change the location of this object (use {@link #setFileName(String)} if
     * you need it).
     *
     * @param fileName the file name
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    public void save(final String fileName) throws ConfigurationException
    {
<span class="fc" id="L819">        save(fileName, checkContentAndGetLocator());</span>
<span class="fc" id="L820">    }</span>

    /**
     * Saves the associated file to the specified URL. This does not change the
     * location of this object (use {@link #setURL(URL)} if you need it).
     *
     * @param url the URL
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    public void save(final URL url) throws ConfigurationException
    {
<span class="fc" id="L832">        save(url, checkContentAndGetLocator());</span>
<span class="fc" id="L833">    }</span>

    /**
     * Saves the associated file to the specified {@code File}. The file is
     * created automatically if it doesn't exist. This does not change the
     * location of this object (use {@link #setFile} if you need it).
     *
     * @param file the target file
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    public void save(final File file) throws ConfigurationException
    {
<span class="fc" id="L846">        save(file, checkContentAndGetLocator());</span>
<span class="fc" id="L847">    }</span>

    /**
     * Saves the associated file to the specified stream using the encoding
     * returned by {@link #getEncoding()}.
     *
     * @param out the output stream
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    public void save(final OutputStream out) throws ConfigurationException
    {
<span class="fc" id="L859">        save(out, checkContentAndGetLocator());</span>
<span class="fc" id="L860">    }</span>

    /**
     * Saves the associated file to the specified stream using the specified
     * encoding. If the encoding is &lt;b&gt;null&lt;/b&gt;, the default encoding is used.
     *
     * @param out the output stream
     * @param encoding the encoding to be used, {@code null} to use the default
     *        encoding
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    public void save(final OutputStream out, final String encoding)
            throws ConfigurationException
    {
<span class="fc" id="L875">        saveToStream(out, encoding, null);</span>
<span class="fc" id="L876">    }</span>

    /**
     * Saves the associated file to the given {@code Writer}.
     *
     * @param out the {@code Writer}
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    public void save(final Writer out) throws ConfigurationException
    {
<span class="fc" id="L887">        checkContent();</span>
<span class="fc" id="L888">        injectNullFileLocator();</span>
<span class="fc" id="L889">        saveToWriter(out);</span>
<span class="fc" id="L890">    }</span>

    /**
     * Prepares a builder for a {@code FileLocator} which does not have a
     * defined file location. Other properties (e.g. encoding or file system)
     * are initialized from the {@code FileLocator} associated with this object.
     *
     * @return the initialized builder for a {@code FileLocator}
     */
    private FileLocatorBuilder prepareNullLocatorBuilder()
    {
<span class="fc" id="L901">        return FileLocatorUtils.fileLocator(getFileLocator()).sourceURL(null)</span>
<span class="fc" id="L902">                .basePath(null).fileName(null);</span>
    }

    /**
     * Checks whether the associated {@code FileBased} object implements the
     * {@code FileLocatorAware} interface. If this is the case, a
     * {@code FileLocator} instance is injected which returns only &lt;b&gt;null&lt;/b&gt;
     * values. This method is called if no file location is available (e.g. if
     * data is to be loaded from a stream). The encoding of the injected locator
     * is derived from this object.
     */
    private void injectNullFileLocator()
    {
<span class="fc bfc" id="L915" title="All 2 branches covered.">        if (getContent() instanceof FileLocatorAware)</span>
        {
<span class="fc" id="L917">            final FileLocator locator = prepareNullLocatorBuilder().create();</span>
<span class="fc" id="L918">            ((FileLocatorAware) getContent()).initFileLocator(locator);</span>
        }
<span class="fc" id="L920">    }</span>

    /**
     * Injects a {@code FileLocator} pointing to the specified URL if the
     * current {@code FileBased} object implements the {@code FileLocatorAware}
     * interface.
     *
     * @param url the URL for the locator
     */
    private void injectFileLocator(final URL url)
    {
<span class="fc bfc" id="L931" title="All 2 branches covered.">        if (url == null)</span>
        {
<span class="fc" id="L933">            injectNullFileLocator();</span>
        }
        else
        {
<span class="fc bfc" id="L937" title="All 2 branches covered.">            if (getContent() instanceof FileLocatorAware)</span>
            {
<span class="fc" id="L939">                final FileLocator locator =</span>
<span class="fc" id="L940">                        prepareNullLocatorBuilder().sourceURL(url).create();</span>
<span class="fc" id="L941">                ((FileLocatorAware) getContent()).initFileLocator(locator);</span>
            }
        }
<span class="fc" id="L944">    }</span>

    /**
     * Obtains a {@code SynchronizerSupport} for the current content. If the
     * content implements this interface, it is returned. Otherwise, result is a
     * dummy object. This method is called before load and save operations. The
     * returned object is used for synchronization.
     *
     * @return the {@code SynchronizerSupport} for synchronization
     */
    private SynchronizerSupport fetchSynchronizerSupport()
    {
<span class="fc bfc" id="L956" title="All 2 branches covered.">        if (getContent() instanceof SynchronizerSupport)</span>
        {
<span class="fc" id="L958">            return (SynchronizerSupport) getContent();</span>
        }
<span class="fc" id="L960">        return DUMMY_SYNC_SUPPORT;</span>
    }

    /**
     * Internal helper method for loading the associated file from the location
     * specified in the given {@code FileLocator}.
     *
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs
     */
    private void load(final FileLocator locator) throws ConfigurationException
    {
<span class="fc" id="L972">        final URL url = FileLocatorUtils.locateOrThrow(locator);</span>
<span class="fc" id="L973">        load(url, locator);</span>
<span class="fc" id="L974">    }</span>

    /**
     * Internal helper method for loading a file from the given URL.
     *
     * @param url the URL
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs
     */
    private void load(final URL url, final FileLocator locator) throws ConfigurationException
    {
<span class="fc" id="L985">        InputStream in = null;</span>

        try
        {
<span class="fc" id="L989">            in = FileLocatorUtils.obtainFileSystem(locator).getInputStream(url);</span>
<span class="fc" id="L990">            loadFromStream(in, locator.getEncoding(), url);</span>
        }
<span class="fc" id="L992">        catch (final ConfigurationException e)</span>
        {
<span class="fc" id="L994">            throw e;</span>
        }
<span class="nc" id="L996">        catch (final Exception e)</span>
        {
<span class="nc" id="L998">            throw new ConfigurationException(</span>
                    &quot;Unable to load the configuration from the URL &quot; + url, e);
        }
        finally
        {
<span class="fc" id="L1003">            closeSilent(in);</span>
<span class="fc" id="L1004">        }</span>
<span class="fc" id="L1005">    }</span>

    /**
     * Internal helper method for loading a file from a file name.
     *
     * @param fileName the file name
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs
     */
    private void load(final String fileName, final FileLocator locator)
            throws ConfigurationException
    {
<span class="fc" id="L1017">        final FileLocator locFileName = createLocatorWithFileName(fileName, locator);</span>
<span class="fc" id="L1018">        final URL url = FileLocatorUtils.locateOrThrow(locFileName);</span>
<span class="fc" id="L1019">        load(url, locator);</span>
<span class="fc" id="L1020">    }</span>

    /**
     * Internal helper method for loading a file from the given input stream.
     *
     * @param in the input stream
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs
     */
    private void load(final InputStream in, final FileLocator locator)
            throws ConfigurationException
    {
<span class="fc" id="L1032">        load(in, locator.getEncoding());</span>
<span class="fc" id="L1033">    }</span>

    /**
     * Internal helper method for loading a file from an input stream.
     *
     * @param in the input stream
     * @param encoding the encoding
     * @param url the URL of the file to be loaded (if known)
     * @throws ConfigurationException if an error occurs
     */
    private void loadFromStream(final InputStream in, final String encoding, final URL url)
            throws ConfigurationException
    {
<span class="fc" id="L1046">        checkContent();</span>
<span class="fc" id="L1047">        final SynchronizerSupport syncSupport = fetchSynchronizerSupport();</span>
<span class="fc" id="L1048">        syncSupport.lock(LockMode.WRITE);</span>
        try
        {
<span class="fc" id="L1051">            injectFileLocator(url);</span>

<span class="fc bfc" id="L1053" title="All 2 branches covered.">            if (getContent() instanceof InputStreamSupport)</span>
            {
<span class="fc" id="L1055">                loadFromStreamDirectly(in);</span>
            }
            else
            {
<span class="fc" id="L1059">                loadFromTransformedStream(in, encoding);</span>
            }
        }
        finally
        {
<span class="fc" id="L1064">            syncSupport.unlock(LockMode.WRITE);</span>
<span class="fc" id="L1065">        }</span>
<span class="fc" id="L1066">    }</span>

    /**
     * Loads data from an input stream if the associated {@code FileBased}
     * object implements the {@code InputStreamSupport} interface.
     *
     * @param in the input stream
     * @throws ConfigurationException if an error occurs
     */
    private void loadFromStreamDirectly(final InputStream in)
            throws ConfigurationException
    {
        try
        {
<span class="fc" id="L1080">            ((InputStreamSupport) getContent()).read(in);</span>
        }
<span class="fc" id="L1082">        catch (final IOException e)</span>
        {
<span class="fc" id="L1084">            throw new ConfigurationException(e);</span>
<span class="fc" id="L1085">        }</span>
<span class="fc" id="L1086">    }</span>

    /**
     * Internal helper method for transforming an input stream to a reader and
     * reading its content.
     *
     * @param in the input stream
     * @param encoding the encoding
     * @throws ConfigurationException if an error occurs
     */
    private void loadFromTransformedStream(final InputStream in, final String encoding)
            throws ConfigurationException
    {
<span class="fc" id="L1099">        Reader reader = null;</span>

<span class="fc bfc" id="L1101" title="All 2 branches covered.">        if (encoding != null)</span>
        {
            try
            {
<span class="fc" id="L1105">                reader = new InputStreamReader(in, encoding);</span>
            }
<span class="nc" id="L1107">            catch (final UnsupportedEncodingException e)</span>
            {
<span class="nc" id="L1109">                throw new ConfigurationException(</span>
                        &quot;The requested encoding is not supported, try the default encoding.&quot;,
                        e);
<span class="fc" id="L1112">            }</span>
        }

<span class="fc bfc" id="L1115" title="All 2 branches covered.">        if (reader == null)</span>
        {
<span class="fc" id="L1117">            reader = new InputStreamReader(in);</span>
        }

<span class="fc" id="L1120">        loadFromReader(reader);</span>
<span class="fc" id="L1121">    }</span>

    /**
     * Internal helper method for loading a file from the given reader.
     *
     * @param in the reader
     * @throws ConfigurationException if an error occurs
     */
    private void loadFromReader(final Reader in) throws ConfigurationException
    {
<span class="fc" id="L1131">        fireLoadingEvent();</span>
        try
        {
<span class="fc" id="L1134">            getContent().read(in);</span>
        }
<span class="fc" id="L1136">        catch (final IOException ioex)</span>
        {
<span class="fc" id="L1138">            throw new ConfigurationException(ioex);</span>
        }
        finally
        {
<span class="fc" id="L1142">            fireLoadedEvent();</span>
<span class="fc" id="L1143">        }</span>
<span class="fc" id="L1144">    }</span>

    /**
     * Internal helper method for saving data to the internal location stored
     * for this object.
     *
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    private void save(final FileLocator locator) throws ConfigurationException
    {
<span class="fc bfc" id="L1156" title="All 2 branches covered.">        if (!FileLocatorUtils.isLocationDefined(locator))</span>
        {
<span class="fc" id="L1158">            throw new ConfigurationException(&quot;No file location has been set!&quot;);</span>
        }

<span class="fc bfc" id="L1161" title="All 2 branches covered.">        if (locator.getSourceURL() != null)</span>
        {
<span class="fc" id="L1163">            save(locator.getSourceURL(), locator);</span>
        }
        else
        {
<span class="fc" id="L1167">            save(locator.getFileName(), locator);</span>
        }
<span class="fc" id="L1169">    }</span>

    /**
     * Internal helper method for saving data to the given file name.
     *
     * @param fileName the path to the target file
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    private void save(final String fileName, final FileLocator locator)
            throws ConfigurationException
    {
        URL url;
        try
        {
<span class="fc" id="L1185">            url = FileLocatorUtils.obtainFileSystem(locator).getURL(</span>
<span class="fc" id="L1186">                    locator.getBasePath(), fileName);</span>
        }
<span class="fc" id="L1188">        catch (final MalformedURLException e)</span>
        {
<span class="fc" id="L1190">            throw new ConfigurationException(e);</span>
<span class="fc" id="L1191">        }</span>

<span class="fc bfc" id="L1193" title="All 2 branches covered.">        if (url == null)</span>
        {
<span class="fc" id="L1195">            throw new ConfigurationException(</span>
                    &quot;Cannot locate configuration source &quot; + fileName);
        }
<span class="fc" id="L1198">        save(url, locator);</span>
<span class="fc" id="L1199">    }</span>

    /**
     * Internal helper method for saving data to the given URL.
     *
     * @param url the target URL
     * @param locator the {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    private void save(final URL url, final FileLocator locator) throws ConfigurationException
    {
<span class="fc" id="L1211">        OutputStream out = null;</span>
        try
        {
<span class="fc" id="L1214">            out = FileLocatorUtils.obtainFileSystem(locator).getOutputStream(url);</span>
<span class="fc" id="L1215">            saveToStream(out, locator.getEncoding(), url);</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">            if (out instanceof VerifiableOutputStream)</span>
            {
                try
                {
<span class="fc" id="L1220">                    ((VerifiableOutputStream) out).verify();</span>
                }
<span class="fc" id="L1222">                catch (final IOException e)</span>
                {
<span class="fc" id="L1224">                    throw new ConfigurationException(e);</span>
<span class="fc" id="L1225">                }</span>
            }
        }
        finally
        {
<span class="fc" id="L1230">            closeSilent(out);</span>
<span class="fc" id="L1231">        }</span>
<span class="fc" id="L1232">    }</span>

    /**
     * Internal helper method for saving data to the given {@code File}.
     *
     * @param file the target file
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    private void save(final File file, final FileLocator locator) throws ConfigurationException
    {
<span class="fc" id="L1244">        OutputStream out = null;</span>

        try
        {
<span class="fc" id="L1248">            out = FileLocatorUtils.obtainFileSystem(locator).getOutputStream(file);</span>
<span class="fc" id="L1249">            saveToStream(out, locator.getEncoding(), file.toURI().toURL());</span>
        }
<span class="nc" id="L1251">        catch (final MalformedURLException muex)</span>
        {
<span class="nc" id="L1253">            throw new ConfigurationException(muex);</span>
        }
        finally
        {
<span class="fc" id="L1257">            closeSilent(out);</span>
<span class="fc" id="L1258">        }</span>
<span class="fc" id="L1259">    }</span>

    /**
     * Internal helper method for saving a file to the given output stream.
     *
     * @param out the output stream
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save
     *         operation
     */
    private void save(final OutputStream out, final FileLocator locator)
            throws ConfigurationException
    {
<span class="fc" id="L1272">        save(out, locator.getEncoding());</span>
<span class="fc" id="L1273">    }</span>

    /**
     * Internal helper method for saving a file to the given stream.
     *
     * @param out the output stream
     * @param encoding the encoding
     * @param url the URL of the output file if known
     * @throws ConfigurationException if an error occurs
     */
    private void saveToStream(final OutputStream out, final String encoding, final URL url)
            throws ConfigurationException
    {
<span class="fc" id="L1286">        checkContent();</span>
<span class="fc" id="L1287">        final SynchronizerSupport syncSupport = fetchSynchronizerSupport();</span>
<span class="fc" id="L1288">        syncSupport.lock(LockMode.WRITE);</span>
        try
        {
<span class="fc" id="L1291">            injectFileLocator(url);</span>
<span class="fc" id="L1292">            Writer writer = null;</span>

<span class="fc bfc" id="L1294" title="All 2 branches covered.">            if (encoding != null)</span>
            {
                try
                {
<span class="fc" id="L1298">                    writer = new OutputStreamWriter(out, encoding);</span>
                }
<span class="nc" id="L1300">                catch (final UnsupportedEncodingException e)</span>
                {
<span class="nc" id="L1302">                    throw new ConfigurationException(</span>
                            &quot;The requested encoding is not supported, try the default encoding.&quot;,
                            e);
<span class="fc" id="L1305">                }</span>
            }

<span class="fc bfc" id="L1308" title="All 2 branches covered.">            if (writer == null)</span>
            {
<span class="fc" id="L1310">                writer = new OutputStreamWriter(out);</span>
            }

<span class="fc" id="L1313">            saveToWriter(writer);</span>
        }
        finally
        {
<span class="fc" id="L1317">            syncSupport.unlock(LockMode.WRITE);</span>
<span class="fc" id="L1318">        }</span>
<span class="fc" id="L1319">    }</span>

    /**
     * Internal helper method for saving a file into the given writer.
     *
     * @param out the writer
     * @throws ConfigurationException if an error occurs
     */
    private void saveToWriter(final Writer out) throws ConfigurationException
    {
<span class="fc" id="L1329">        fireSavingEvent();</span>
        try
        {
<span class="fc" id="L1332">            getContent().write(out);</span>
        }
<span class="fc" id="L1334">        catch (final IOException ioex)</span>
        {
<span class="fc" id="L1336">            throw new ConfigurationException(ioex);</span>
        }
        finally
        {
<span class="fc" id="L1340">            fireSavedEvent();</span>
<span class="fc" id="L1341">        }</span>
<span class="fc" id="L1342">    }</span>

    /**
     * Creates a {@code FileLocator} which is a copy of the passed in one, but
     * has the given file name set to reference the target file.
     *
     * @param fileName the file name
     * @param locator the {@code FileLocator} to copy
     * @return the manipulated {@code FileLocator} with the file name
     */
    private FileLocator createLocatorWithFileName(final String fileName,
            final FileLocator locator)
    {
<span class="fc" id="L1355">        return FileLocatorUtils.fileLocator(locator).sourceURL(null)</span>
<span class="fc" id="L1356">                .fileName(fileName).create();</span>
    }

    /**
     * Checks whether a content object is available. If not, an exception is
     * thrown. This method is called whenever the content object is accessed.
     *
     * @throws ConfigurationException if not content object is defined
     */
    private void checkContent() throws ConfigurationException
    {
<span class="fc bfc" id="L1367" title="All 2 branches covered.">        if (getContent() == null)</span>
        {
<span class="fc" id="L1369">            throw new ConfigurationException(&quot;No content available!&quot;);</span>
        }
<span class="fc" id="L1371">    }</span>

    /**
     * Checks whether a content object is available and returns the current
     * {@code FileLocator}. If there is no content object, an exception is
     * thrown. This is a typical operation to be performed before a load() or
     * save() operation.
     *
     * @return the current {@code FileLocator} to be used for the calling
     *         operation
     */
    private FileLocator checkContentAndGetLocator()
            throws ConfigurationException
    {
<span class="fc" id="L1385">        checkContent();</span>
<span class="fc" id="L1386">        return getFileLocator();</span>
    }

    /**
     * Notifies the registered listeners about the start of a load operation.
     */
    private void fireLoadingEvent()
    {
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        for (final FileHandlerListener l : listeners)</span>
        {
<span class="fc" id="L1396">            l.loading(this);</span>
<span class="fc" id="L1397">        }</span>
<span class="fc" id="L1398">    }</span>

    /**
     * Notifies the registered listeners about a completed load operation.
     */
    private void fireLoadedEvent()
    {
<span class="fc bfc" id="L1405" title="All 2 branches covered.">        for (final FileHandlerListener l : listeners)</span>
        {
<span class="fc" id="L1407">            l.loaded(this);</span>
<span class="fc" id="L1408">        }</span>
<span class="fc" id="L1409">    }</span>

    /**
     * Notifies the registered listeners about the start of a save operation.
     */
    private void fireSavingEvent()
    {
<span class="fc bfc" id="L1416" title="All 2 branches covered.">        for (final FileHandlerListener l : listeners)</span>
        {
<span class="fc" id="L1418">            l.saving(this);</span>
<span class="fc" id="L1419">        }</span>
<span class="fc" id="L1420">    }</span>

    /**
     * Notifies the registered listeners about a completed save operation.
     */
    private void fireSavedEvent()
    {
<span class="fc bfc" id="L1427" title="All 2 branches covered.">        for (final FileHandlerListener l : listeners)</span>
        {
<span class="fc" id="L1429">            l.saved(this);</span>
<span class="fc" id="L1430">        }</span>
<span class="fc" id="L1431">    }</span>

    /**
     * Notifies the registered listeners about a property update.
     */
    private void fireLocationChangedEvent()
    {
<span class="fc bfc" id="L1438" title="All 2 branches covered.">        for (final FileHandlerListener l : listeners)</span>
        {
<span class="fc" id="L1440">            l.locationChanged(this);</span>
<span class="fc" id="L1441">        }</span>
<span class="fc" id="L1442">    }</span>

    /**
     * Normalizes URLs to files. Ensures that file URLs start with the correct
     * protocol.
     *
     * @param fileName the string to be normalized
     * @return the normalized file URL
     */
    private static String normalizeFileURL(String fileName)
    {
<span class="fc bfc" id="L1453" title="All 4 branches covered.">        if (fileName != null &amp;&amp; fileName.startsWith(FILE_SCHEME)</span>
<span class="fc bfc" id="L1454" title="All 2 branches covered.">                &amp;&amp; !fileName.startsWith(FILE_SCHEME_SLASH))</span>
        {
<span class="fc" id="L1456">            fileName =</span>
                    FILE_SCHEME_SLASH
<span class="fc" id="L1458">                            + fileName.substring(FILE_SCHEME.length());</span>
        }
<span class="fc" id="L1460">        return fileName;</span>
    }

    /**
     * A helper method for closing a stream. Occurring exceptions will be
     * ignored.
     *
     * @param cl the stream to be closed (may be &lt;b&gt;null&lt;/b&gt;)
     */
    private static void closeSilent(final Closeable cl)
    {
        try
        {
<span class="fc bfc" id="L1473" title="All 2 branches covered.">            if (cl != null)</span>
            {
<span class="fc" id="L1475">                cl.close();</span>
            }
        }
<span class="nc" id="L1478">        catch (final IOException e)</span>
        {
<span class="nc" id="L1480">            LogFactory.getLog(FileHandler.class).warn(&quot;Exception when closing &quot; + cl, e);</span>
<span class="fc" id="L1481">        }</span>
<span class="fc" id="L1482">    }</span>

    /**
     * Creates a {@code File} object from the content of the given
     * {@code FileLocator} object. If the locator is not defined, result is
     * &lt;b&gt;null&lt;/b&gt;.
     *
     * @param loc the {@code FileLocator}
     * @return a {@code File} object pointing to the associated file
     */
    private static File createFile(final FileLocator loc)
    {
<span class="pc bpc" id="L1494" title="1 of 4 branches missed.">        if (loc.getFileName() == null &amp;&amp; loc.getSourceURL() == null)</span>
        {
<span class="fc" id="L1496">            return null;</span>
        }
<span class="pc bpc" id="L1498" title="1 of 2 branches missed.">        else if (loc.getSourceURL() != null)</span>
        {
<span class="nc" id="L1500">            return FileLocatorUtils.fileFromURL(loc.getSourceURL());</span>
        }
        else
        {
<span class="fc" id="L1504">            return FileLocatorUtils.getFile(loc.getBasePath(),</span>
<span class="fc" id="L1505">                    loc.getFileName());</span>
        }
    }

    /**
     * Creates an uninitialized file locator.
     *
     * @return the locator
     */
    private static FileLocator emptyFileLocator()
    {
<span class="fc" id="L1516">        return FileLocatorUtils.fileLocator().create();</span>
    }

    /**
     * Helper method for checking a file handler which is to be copied. Throws
     * an exception if the handler is &lt;b&gt;null&lt;/b&gt;.
     *
     * @param c the {@code FileHandler} from which to copy the location
     * @return the same {@code FileHandler}
     */
    private static FileHandler checkSourceHandler(final FileHandler c)
    {
<span class="fc bfc" id="L1528" title="All 2 branches covered.">        if (c == null)</span>
        {
<span class="fc" id="L1530">            throw new IllegalArgumentException(</span>
                    &quot;FileHandler to assign must not be null!&quot;);
        }
<span class="fc" id="L1533">        return c;</span>
    }

    /**
     * An internal class that performs all update operations of the handler's
     * {@code FileLocator} in a safe way even if there is concurrent access.
     * This class implements anon-blocking algorithm for replacing the immutable
     * {@code FileLocator} instance stored in an atomic reference by a
     * manipulated instance. (If we already had lambdas, this could be done
     * without a class in a more elegant way.)
     */
<span class="fc" id="L1544">    private abstract class Updater</span>
    {
        /**
         * Performs an update of the enclosing file handler's
         * {@code FileLocator} object.
         */
        public void update()
        {
            boolean done;
            do
            {
<span class="fc" id="L1555">                final FileLocator oldLocator = fileLocator.get();</span>
<span class="fc" id="L1556">                final FileLocatorBuilder builder =</span>
<span class="fc" id="L1557">                        FileLocatorUtils.fileLocator(oldLocator);</span>
<span class="fc" id="L1558">                updateBuilder(builder);</span>
<span class="fc" id="L1559">                done = fileLocator.compareAndSet(oldLocator, builder.create());</span>
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">            } while (!done);</span>
<span class="fc" id="L1561">            fireLocationChangedEvent();</span>
<span class="fc" id="L1562">        }</span>

        /**
         * Updates the passed in builder object to apply the manipulation to be
         * performed by this {@code Updater}. The builder has been setup with
         * the former content of the {@code FileLocator} to be manipulated.
         *
         * @param builder the builder for creating an updated
         *        {@code FileLocator}
         */
        protected abstract void updateBuilder(FileLocatorBuilder builder);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>