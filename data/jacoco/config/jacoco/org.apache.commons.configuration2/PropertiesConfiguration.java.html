<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PropertiesConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2</a> &gt; <span class="el_source">PropertiesConfiguration.java</span></div><h1>PropertiesConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.configuration2;

import java.io.FilterWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.Reader;
import java.io.Writer;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.configuration2.convert.ListDelimiterHandler;
import org.apache.commons.configuration2.convert.ValueTransformer;
import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;
import org.apache.commons.configuration2.io.FileHandler;
import org.apache.commons.configuration2.io.FileLocator;
import org.apache.commons.configuration2.io.FileLocatorAware;
import org.apache.commons.configuration2.io.FileLocatorUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.commons.text.translate.AggregateTranslator;
import org.apache.commons.text.translate.CharSequenceTranslator;
import org.apache.commons.text.translate.EntityArrays;
import org.apache.commons.text.translate.LookupTranslator;
import org.apache.commons.text.translate.UnicodeEscaper;

/**
 * This is the &quot;classic&quot; Properties loader which loads the values from
 * a single or multiple files (which can be chained with &quot;include =&quot;.
 * All given path references are either absolute or relative to the
 * file name supplied in the constructor.
 * &lt;p&gt;
 * In this class, empty PropertyConfigurations can be built, properties
 * added and later saved. include statements are (obviously) not supported
 * if you don't construct a PropertyConfiguration from a file.
 *
 * &lt;p&gt;The properties file syntax is explained here, basically it follows
 * the syntax of the stream parsed by {@link java.util.Properties#load} and
 * adds several useful extensions:
 *
 * &lt;ul&gt;
 *  &lt;li&gt;
 *   Each property has the syntax &lt;code&gt;key &amp;lt;separator&amp;gt; value&lt;/code&gt;. The
 *   separators accepted are {@code '='}, {@code ':'} and any white
 *   space character. Examples:
 * &lt;pre&gt;
 *  key1 = value1
 *  key2 : value2
 *  key3   value3&lt;/pre&gt;
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   The &lt;i&gt;key&lt;/i&gt; may use any character, separators must be escaped:
 * &lt;pre&gt;
 *  key\:foo = bar&lt;/pre&gt;
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   &lt;i&gt;value&lt;/i&gt; may be separated on different lines if a backslash
 *   is placed at the end of the line that continues below.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   The list delimiter facilities provided by {@link AbstractConfiguration}
 *   are supported, too. If an appropriate {@link ListDelimiterHandler} is
 *   set (for instance
 *   a {@link org.apache.commons.configuration2.convert.DefaultListDelimiterHandler D
 *   efaultListDelimiterHandler} object configured
 *   with a comma as delimiter character), &lt;i&gt;value&lt;/i&gt; can contain &lt;em&gt;value
 *   delimiters&lt;/em&gt; and will then be interpreted as a list of tokens. So the
 *   following property definition
 * &lt;pre&gt;
 *  key = This property, has multiple, values
 * &lt;/pre&gt;
 *   will result in a property with three values. You can change the handling
 *   of delimiters using the
 *   {@link AbstractConfiguration#setListDelimiterHandler(ListDelimiterHandler)}
 *   method. Per default, list splitting is disabled.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   Commas in each token are escaped placing a backslash right before
 *   the comma.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   If a &lt;i&gt;key&lt;/i&gt; is used more than once, the values are appended
 *   like if they were on the same line separated with commas. &lt;em&gt;Note&lt;/em&gt;:
 *   When the configuration file is written back to disk the associated
 *   {@link PropertiesConfigurationLayout} object (see below) will
 *   try to preserve as much of the original format as possible, i.e. properties
 *   with multiple values defined on a single line will also be written back on
 *   a single line, and multiple occurrences of a single key will be written on
 *   multiple lines. If the {@code addProperty()} method was called
 *   multiple times for adding multiple values to a property, these properties
 *   will per default be written on multiple lines in the output file, too.
 *   Some options of the {@code PropertiesConfigurationLayout} class have
 *   influence on that behavior.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   Blank lines and lines starting with character '#' or '!' are skipped.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   If a property is named &quot;include&quot; (or whatever is defined by
 *   setInclude() and getInclude() and the value of that property is
 *   the full path to a file on disk, that file will be included into
 *   the configuration. You can also pull in files relative to the parent
 *   configuration file. So if you have something like the following:
 *
 *   include = additional.properties
 *
 *   Then &quot;additional.properties&quot; is expected to be in the same
 *   directory as the parent configuration file.
 *
 *   The properties in the included file are added to the parent configuration,
 *   they do not replace existing properties with the same key.
 *
 *  &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Here is an example of a valid extended properties file:&lt;/p&gt;
 *
 * &lt;pre&gt;
 *      # lines starting with # are comments
 *
 *      # This is the simplest property
 *      key = value
 *
 *      # A long property may be separated on multiple lines
 *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
 *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 *
 *      # This is a property with many tokens
 *      tokens_on_a_line = first token, second token
 *
 *      # This sequence generates exactly the same result
 *      tokens_on_multiple_lines = first token
 *      tokens_on_multiple_lines = second token
 *
 *      # commas may be escaped in tokens
 *      commas.escaped = Hi\, what'up?
 *
 *      # properties can reference other properties
 *      base.prop = /base
 *      first.prop = ${base.prop}/first
 *      second.prop = ${first.prop}/second
 * &lt;/pre&gt;
 *
 * &lt;p&gt;A {@code PropertiesConfiguration} object is associated with an
 * instance of the {@link PropertiesConfigurationLayout} class,
 * which is responsible for storing the layout of the parsed properties file
 * (i.e. empty lines, comments, and such things). The {@code getLayout()}
 * method can be used to obtain this layout object. With {@code setLayout()}
 * a new layout object can be set. This should be done before a properties file
 * was loaded.
 * &lt;p&gt;Like other {@code Configuration} implementations, this class uses a
 * {@code Synchronizer} object to control concurrent access. By choosing a
 * suitable implementation of the {@code Synchronizer} interface, an instance
 * can be made thread-safe or not. Note that access to most of the properties
 * typically set through a builder is not protected by the {@code Synchronizer}.
 * The intended usage is that these properties are set once at construction
 * time through the builder and after that remain constant. If you wish to
 * change such properties during life time of an instance, you have to use
 * the {@code lock()} and {@code unlock()} methods manually to ensure that
 * other threads see your changes.
 * &lt;p&gt;As this class extends {@link AbstractConfiguration}, all basic features
 * like variable interpolation, list handling, or data type conversions are
 * available as well. This is described in the chapter
 * &lt;a href=&quot;http://commons.apache.org/proper/commons-configuration/userguide/howto_basicfeatures.html&quot;&gt;
 * Basic features and AbstractConfiguration&lt;/a&gt; of the user's guide. There is
 * also a separate chapter dealing with
 * &lt;a href=&quot;commons.apache.org/proper/commons-configuration/userguide/howto_properties.html&quot;&gt;
 * Properties files&lt;/a&gt; in special.
 *
 * @see java.util.Properties#load
 *
 * @author &lt;a href=&quot;mailto:stefano@apache.org&quot;&gt;Stefano Mazzocchi&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:jon@latchkey.com&quot;&gt;Jon S. Stevens&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:daveb@miceda-data&quot;&gt;Dave Bryson&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:geirm@optonline.net&quot;&gt;Geir Magnusson Jr.&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:leon@opticode.co.za&quot;&gt;Leon Messerschmidt&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:kjohnson@transparent.com&quot;&gt;Kent Johnson&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:dlr@finemaltcoding.com&quot;&gt;Daniel Rall&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:ipriha@surfeu.fi&quot;&gt;Ilkka Priha&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:jvanzyl@apache.org&quot;&gt;Jason van Zyl&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:mpoeschl@marmot.at&quot;&gt;Martin Poeschl&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:hps@intermeta.de&quot;&gt;Henning P. Schmiedehausen&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:epugh@upstate.com&quot;&gt;Eric Pugh&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:ebourg@apache.org&quot;&gt;Emmanuel Bourg&lt;/a&gt;
 * @version $Id$
 */
public class PropertiesConfiguration extends BaseConfiguration
    implements FileBasedConfiguration, FileLocatorAware
{
    /**
     * The default encoding (ISO-8859-1 as specified by
     * http://java.sun.com/j2se/1.5.0/docs/api/java/util/Properties.html)
     */
    public static final String DEFAULT_ENCODING = &quot;ISO-8859-1&quot;;

    /** Constant for the supported comment characters.*/
    static final String COMMENT_CHARS = &quot;#!&quot;;

    /** Constant for the default properties separator.*/
    static final String DEFAULT_SEPARATOR = &quot; = &quot;;

    /**
     * Constant for the default {@code IOFactory}. This instance is used
     * when no specific factory was set.
     */
<span class="fc" id="L232">    private static final IOFactory DEFAULT_IO_FACTORY = new DefaultIOFactory();</span>

    /**
     * A string with special characters that need to be unescaped when reading
     * a properties file. {@code java.util.Properties} escapes these characters
     * when writing out a properties file.
     */
    private static final String UNESCAPE_CHARACTERS = &quot;:#=!\\\'\&quot;&quot;;

    /**
     * This is the name of the property that can point to other
     * properties file for including other properties files.
     */
<span class="fc" id="L245">    private static String include = &quot;include&quot;;</span>

    /** The list of possible key/value separators */
<span class="fc" id="L248">    private static final char[] SEPARATORS = new char[] {'=', ':'};</span>

    /** The white space characters used as key/value separators. */
<span class="fc" id="L251">    private static final char[] WHITE_SPACE = new char[]{' ', '\t', '\f'};</span>

    /** Constant for the platform specific line separator.*/
<span class="fc" id="L254">    private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;);</span>

    /** Constant for the radix of hex numbers.*/
    private static final int HEX_RADIX = 16;

    /** Constant for the length of a unicode literal.*/
    private static final int UNICODE_LEN = 4;

    /** Stores the layout object.*/
    private PropertiesConfigurationLayout layout;

    /** The IOFactory for creating readers and writers.*/
    private IOFactory ioFactory;

    /** The current {@code FileLocator}. */
    private FileLocator locator;

    /** Allow file inclusion or not */
<span class="fc" id="L272">    private boolean includesAllowed = true;</span>

    /**
     * Creates an empty PropertyConfiguration object which can be
     * used to synthesize a new Properties file by adding values and
     * then saving().
     */
    public PropertiesConfiguration()
<span class="fc" id="L280">    {</span>
<span class="fc" id="L281">        installLayout(createLayout());</span>
<span class="fc" id="L282">    }</span>

    /**
     * Gets the property value for including other properties files.
     * By default it is &quot;include&quot;.
     *
     * @return A String.
     */
    public static String getInclude()
    {
<span class="fc" id="L292">        return PropertiesConfiguration.include;</span>
    }

    /**
     * Sets the property value for including other properties files.
     * By default it is &quot;include&quot;.
     *
     * @param inc A String.
     */
    public static void setInclude(final String inc)
    {
<span class="fc" id="L303">        PropertiesConfiguration.include = inc;</span>
<span class="fc" id="L304">    }</span>

    /**
     * Controls whether additional files can be loaded by the {@code include = &lt;xxx&gt;}
     * statement or not. This is &lt;b&gt;true&lt;/b&gt; per default.
     *
     * @param includesAllowed True if Includes are allowed.
     */
    public void setIncludesAllowed(final boolean includesAllowed)
    {
<span class="fc" id="L314">        this.includesAllowed = includesAllowed;</span>
<span class="fc" id="L315">    }</span>

    /**
     * Reports the status of file inclusion.
     *
     * @return True if include files are loaded.
     */
    public boolean isIncludesAllowed()
    {
<span class="fc" id="L324">        return this.includesAllowed;</span>
    }

    /**
     * Return the comment header.
     *
     * @return the comment header
     * @since 1.1
     */
    public String getHeader()
    {
<span class="fc" id="L335">        beginRead(false);</span>
        try
        {
<span class="fc" id="L338">            return getLayout().getHeaderComment();</span>
        }
        finally
        {
<span class="pc" id="L342">            endRead();</span>
<span class="nc" id="L343">        }</span>
    }

    /**
     * Set the comment header.
     *
     * @param header the header to use
     * @since 1.1
     */
    public void setHeader(final String header)
    {
<span class="fc" id="L354">        beginWrite(false);</span>
        try
        {
<span class="fc" id="L357">            getLayout().setHeaderComment(header);</span>
        }
        finally
        {
<span class="pc" id="L361">            endWrite();</span>
<span class="pc" id="L362">        }</span>
<span class="fc" id="L363">    }</span>

    /**
     * Returns the footer comment. This is a comment at the very end of the
     * file.
     *
     * @return the footer comment
     * @since 2.0
     */
    public String getFooter()
    {
<span class="fc" id="L374">        beginRead(false);</span>
        try
        {
<span class="fc" id="L377">            return getLayout().getFooterComment();</span>
        }
        finally
        {
<span class="pc" id="L381">            endRead();</span>
<span class="nc" id="L382">        }</span>
    }

    /**
     * Sets the footer comment. If set, this comment is written after all
     * properties at the end of the file.
     *
     * @param footer the footer comment
     * @since 2.0
     */
    public void setFooter(final String footer)
    {
<span class="fc" id="L394">        beginWrite(false);</span>
        try
        {
<span class="fc" id="L397">            getLayout().setFooterComment(footer);</span>
        }
        finally
        {
<span class="pc" id="L401">            endWrite();</span>
<span class="pc" id="L402">        }</span>
<span class="fc" id="L403">    }</span>

    /**
     * Returns the associated layout object.
     *
     * @return the associated layout object
     * @since 1.3
     */
    public PropertiesConfigurationLayout getLayout()
    {
<span class="fc" id="L413">        return layout;</span>
    }

    /**
     * Sets the associated layout object.
     *
     * @param layout the new layout object; can be &lt;b&gt;null&lt;/b&gt;, then a new
     * layout object will be created
     * @since 1.3
     */
    public void setLayout(final PropertiesConfigurationLayout layout)
    {
<span class="fc" id="L425">        installLayout(layout);</span>
<span class="fc" id="L426">    }</span>

    /**
     * Installs a layout object. It has to be ensured that the layout is
     * registered as change listener at this configuration. If there is already
     * a layout object installed, it has to be removed properly.
     *
     * @param layout the layout object to be installed
     */
    private void installLayout(final PropertiesConfigurationLayout layout)
    {
        // only one layout must exist
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (this.layout != null)</span>
        {
<span class="fc" id="L440">            removeEventListener(ConfigurationEvent.ANY, this.layout);</span>
        }

<span class="fc bfc" id="L443" title="All 2 branches covered.">        if (layout == null)</span>
        {
<span class="fc" id="L445">            this.layout = createLayout();</span>
        }
        else
        {
<span class="fc" id="L449">            this.layout = layout;</span>
        }
<span class="fc" id="L451">        addEventListener(ConfigurationEvent.ANY, this.layout);</span>
<span class="fc" id="L452">    }</span>

    /**
     * Creates a standard layout object. This configuration is initialized with
     * such a standard layout.
     *
     * @return the newly created layout object
     */
    private PropertiesConfigurationLayout createLayout()
    {
<span class="fc" id="L462">        return new PropertiesConfigurationLayout();</span>
    }

    /**
     * Returns the {@code IOFactory} to be used for creating readers and
     * writers when loading or saving this configuration.
     *
     * @return the {@code IOFactory}
     * @since 1.7
     */
    public IOFactory getIOFactory()
    {
<span class="fc bfc" id="L474" title="All 2 branches covered.">        return (ioFactory != null) ? ioFactory : DEFAULT_IO_FACTORY;</span>
    }

    /**
     * Sets the {@code IOFactory} to be used for creating readers and
     * writers when loading or saving this configuration. Using this method a
     * client can customize the reader and writer classes used by the load and
     * save operations. Note that this method must be called before invoking
     * one of the {@code load()} and {@code save()} methods.
     * Especially, if you want to use a custom {@code IOFactory} for
     * changing the {@code PropertiesReader}, you cannot load the
     * configuration data in the constructor.
     *
     * @param ioFactory the new {@code IOFactory} (must not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the {@code IOFactory} is
     *         &lt;b&gt;null&lt;/b&gt;
     * @since 1.7
     */
    public void setIOFactory(final IOFactory ioFactory)
    {
<span class="fc bfc" id="L494" title="All 2 branches covered.">        if (ioFactory == null)</span>
        {
<span class="fc" id="L496">            throw new IllegalArgumentException(&quot;IOFactory must not be null!&quot;);</span>
        }

<span class="fc" id="L499">        this.ioFactory = ioFactory;</span>
<span class="fc" id="L500">    }</span>

    /**
     * Stores the current {@code FileLocator} for a following IO operation. The
     * {@code FileLocator} is needed to resolve include files with relative file
     * names.
     *
     * @param locator the current {@code FileLocator}
     * @since 2.0
     */
    @Override
    public void initFileLocator(final FileLocator locator)
    {
<span class="fc" id="L513">        this.locator = locator;</span>
<span class="fc" id="L514">    }</span>

    /**
     * {@inheritDoc} This implementation delegates to the associated layout
     * object which does the actual loading. Note that this method does not
     * do any synchronization. This lies in the responsibility of the caller.
     * (Typically, the caller is a {@code FileHandler} object which takes
     * care for proper synchronization.)
     *
     * @since 2.0
     */
    @Override
    public void read(final Reader in) throws ConfigurationException, IOException
    {
<span class="fc" id="L528">        getLayout().load(this, in);</span>
<span class="fc" id="L529">    }</span>

    /**
     * {@inheritDoc} This implementation delegates to the associated layout
     * object which does the actual saving. Note that, analogous to
     * {@link #read(Reader)}, this method does not do any synchronization.
     *
     * @since 2.0
     */
    @Override
    public void write(final Writer out) throws ConfigurationException, IOException
    {
<span class="fc" id="L541">        getLayout().save(this, out);</span>
<span class="fc" id="L542">    }</span>

    /**
     * Creates a copy of this object.
     *
     * @return the copy
     */
    @Override
    public Object clone()
    {
<span class="fc" id="L552">        final PropertiesConfiguration copy = (PropertiesConfiguration) super.clone();</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (layout != null)</span>
        {
<span class="fc" id="L555">            copy.setLayout(new PropertiesConfigurationLayout(layout));</span>
        }
<span class="fc" id="L557">        return copy;</span>
    }

    /**
     * This method is invoked by the associated
     * {@link PropertiesConfigurationLayout} object for each
     * property definition detected in the parsed properties file. Its task is
     * to check whether this is a special property definition (e.g. the
     * {@code include} property). If not, the property must be added to
     * this configuration. The return value indicates whether the property
     * should be treated as a normal property. If it is &lt;b&gt;false&lt;/b&gt;, the
     * layout object will ignore this property.
     *
     * @param key the property key
     * @param value the property value
     * @return a flag whether this is a normal property
     * @throws ConfigurationException if an error occurs
     * @since 1.3
     */
    boolean propertyLoaded(final String key, final String value)
            throws ConfigurationException
    {
        boolean result;

<span class="pc bpc" id="L581" title="1 of 2 branches missed.">        if (StringUtils.isNotEmpty(getInclude())</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                &amp;&amp; key.equalsIgnoreCase(getInclude()))</span>
        {
<span class="fc bfc" id="L584" title="All 2 branches covered.">            if (isIncludesAllowed())</span>
            {
<span class="fc" id="L586">                final Collection&lt;String&gt; files =</span>
<span class="fc" id="L587">                        getListDelimiterHandler().split(value, true);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                for (final String f : files)</span>
                {
<span class="fc" id="L590">                    loadIncludeFile(interpolate(f));</span>
<span class="fc" id="L591">                }</span>
            }
<span class="fc" id="L593">            result = false;</span>
        }

        else
        {
<span class="fc" id="L598">            addPropertyInternal(key, value);</span>
<span class="fc" id="L599">            result = true;</span>
        }

<span class="fc" id="L602">        return result;</span>
    }

    /**
     * Tests whether a line is a comment, i.e. whether it starts with a comment
     * character.
     *
     * @param line the line
     * @return a flag if this is a comment line
     * @since 1.3
     */
    static boolean isCommentLine(final String line)
    {
<span class="fc" id="L615">        final String s = line.trim();</span>
        // blanc lines are also treated as comment lines
<span class="fc bfc" id="L617" title="All 4 branches covered.">        return s.length() &lt; 1 || COMMENT_CHARS.indexOf(s.charAt(0)) &gt;= 0;</span>
    }

    /**
     * Returns the number of trailing backslashes. This is sometimes needed for
     * the correct handling of escape characters.
     *
     * @param line the string to investigate
     * @return the number of trailing backslashes
     */
    private static int countTrailingBS(final String line)
    {
<span class="fc" id="L629">        int bsCount = 0;</span>
<span class="pc bpc" id="L630" title="1 of 4 branches missed.">        for (int idx = line.length() - 1; idx &gt;= 0 &amp;&amp; line.charAt(idx) == '\\'; idx--)</span>
        {
<span class="fc" id="L632">            bsCount++;</span>
        }

<span class="fc" id="L635">        return bsCount;</span>
    }

    /**
     * This class is used to read properties lines. These lines do
     * not terminate with new-line chars but rather when there is no
     * backslash sign a the end of the line.  This is used to
     * concatenate multiple lines for readability.
     */
    public static class PropertiesReader extends LineNumberReader
    {
        /** The regular expression to parse the key and the value of a property. */
<span class="fc" id="L647">        private static final Pattern PROPERTY_PATTERN = Pattern</span>
<span class="fc" id="L648">                .compile(&quot;(([\\S&amp;&amp;[^\\\\&quot; + new String(SEPARATORS)</span>
<span class="fc" id="L649">                        + &quot;]]|\\\\.)*)(\\s*(\\s+|[&quot; + new String(SEPARATORS)</span>
                        + &quot;])\\s*)?(.*)&quot;);

        /** Constant for the index of the group for the key. */
        private static final int IDX_KEY = 1;

        /** Constant for the index of the group for the value. */
        private static final int IDX_VALUE = 5;

        /** Constant for the index of the group for the separator. */
        private static final int IDX_SEPARATOR = 3;

        /** Stores the comment lines for the currently processed property.*/
        private final List&lt;String&gt; commentLines;

        /** Stores the name of the last read property.*/
        private String propertyName;

        /** Stores the value of the last read property.*/
        private String propertyValue;

        /** Stores the property separator of the last read property.*/
<span class="fc" id="L671">        private String propertySeparator = DEFAULT_SEPARATOR;</span>

        /**
         * Constructor.
         *
         * @param reader A Reader.
         */
        public PropertiesReader(final Reader reader)
        {
<span class="fc" id="L680">            super(reader);</span>
<span class="fc" id="L681">            commentLines = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L682">        }</span>

        /**
         * Reads a property line. Returns null if Stream is
         * at EOF. Concatenates lines ending with &quot;\&quot;.
         * Skips lines beginning with &quot;#&quot; or &quot;!&quot; and empty lines.
         * The return value is a property definition (&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;
         * = &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt;)
         *
         * @return A string containing a property value or null
         *
         * @throws IOException in case of an I/O error
         */
        public String readProperty() throws IOException
        {
<span class="fc" id="L697">            commentLines.clear();</span>
<span class="fc" id="L698">            final StringBuilder buffer = new StringBuilder();</span>

            while (true)
            {
<span class="fc" id="L702">                String line = readLine();</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">                if (line == null)</span>
                {
                    // EOF
<span class="fc" id="L706">                    return null;</span>
                }

<span class="fc bfc" id="L709" title="All 2 branches covered.">                if (isCommentLine(line))</span>
                {
<span class="fc" id="L711">                    commentLines.add(line);</span>
<span class="fc" id="L712">                    continue;</span>
                }

<span class="fc" id="L715">                line = line.trim();</span>

<span class="fc bfc" id="L717" title="All 2 branches covered.">                if (checkCombineLines(line))</span>
                {
<span class="fc" id="L719">                    line = line.substring(0, line.length() - 1);</span>
<span class="fc" id="L720">                    buffer.append(line);</span>
                }
                else
                {
<span class="fc" id="L724">                    buffer.append(line);</span>
<span class="fc" id="L725">                    break;</span>
                }
<span class="fc" id="L727">            }</span>
<span class="fc" id="L728">            return buffer.toString();</span>
        }

        /**
         * Parses the next property from the input stream and stores the found
         * name and value in internal fields. These fields can be obtained using
         * the provided getter methods. The return value indicates whether EOF
         * was reached (&lt;b&gt;false&lt;/b&gt;) or whether further properties are
         * available (&lt;b&gt;true&lt;/b&gt;).
         *
         * @return a flag if further properties are available
         * @throws IOException if an error occurs
         * @since 1.3
         */
        public boolean nextProperty() throws IOException
        {
<span class="fc" id="L744">            final String line = readProperty();</span>

<span class="fc bfc" id="L746" title="All 2 branches covered.">            if (line == null)</span>
            {
<span class="fc" id="L748">                return false; // EOF</span>
            }

            // parse the line
<span class="fc" id="L752">            parseProperty(line);</span>
<span class="fc" id="L753">            return true;</span>
        }

        /**
         * Returns the comment lines that have been read for the last property.
         *
         * @return the comment lines for the last property returned by
         * {@code readProperty()}
         * @since 1.3
         */
        public List&lt;String&gt; getCommentLines()
        {
<span class="fc" id="L765">            return commentLines;</span>
        }

        /**
         * Returns the name of the last read property. This method can be called
         * after {@link #nextProperty()} was invoked and its
         * return value was &lt;b&gt;true&lt;/b&gt;.
         *
         * @return the name of the last read property
         * @since 1.3
         */
        public String getPropertyName()
        {
<span class="fc" id="L778">            return propertyName;</span>
        }

        /**
         * Returns the value of the last read property. This method can be
         * called after {@link #nextProperty()} was invoked and
         * its return value was &lt;b&gt;true&lt;/b&gt;.
         *
         * @return the value of the last read property
         * @since 1.3
         */
        public String getPropertyValue()
        {
<span class="fc" id="L791">            return propertyValue;</span>
        }

        /**
         * Returns the separator that was used for the last read property. The
         * separator can be stored so that it can later be restored when saving
         * the configuration.
         *
         * @return the separator for the last read property
         * @since 1.7
         */
        public String getPropertySeparator()
        {
<span class="fc" id="L804">            return propertySeparator;</span>
        }

        /**
         * Parses a line read from the properties file. This method is called
         * for each non-comment line read from the source file. Its task is to
         * split the passed in line into the property key and its value. The
         * results of the parse operation can be stored by calling the
         * {@code initPropertyXXX()} methods.
         *
         * @param line the line read from the properties file
         * @since 1.7
         */
        protected void parseProperty(final String line)
        {
<span class="fc" id="L819">            final String[] property = doParseProperty(line, true);</span>
<span class="fc" id="L820">            initPropertyName(property[0]);</span>
<span class="fc" id="L821">            initPropertyValue(property[1]);</span>
<span class="fc" id="L822">            initPropertySeparator(property[2]);</span>
<span class="fc" id="L823">        }</span>

        /**
         * Sets the name of the current property. This method can be called by
         * {@code parseProperty()} for storing the results of the parse
         * operation. It also ensures that the property key is correctly
         * escaped.
         *
         * @param name the name of the current property
         * @since 1.7
         */
        protected void initPropertyName(final String name)
        {
<span class="fc" id="L836">            propertyName = unescapePropertyName(name);</span>
<span class="fc" id="L837">        }</span>

        /**
         * Performs unescaping on the given property name.
         *
         * @param name the property name
         * @return the unescaped property name
         * @since 2.4
         */
        protected String unescapePropertyName(String name)
        {
<span class="fc" id="L848">            return StringEscapeUtils.unescapeJava(name);</span>
        }

        /**
         * Sets the value of the current property. This method can be called by
         * {@code parseProperty()} for storing the results of the parse
         * operation. It also ensures that the property value is correctly
         * escaped.
         *
         * @param value the value of the current property
         * @since 1.7
         */
        protected void initPropertyValue(final String value)
        {
<span class="fc" id="L862">            propertyValue = unescapePropertyValue(value);</span>
<span class="fc" id="L863">        }</span>

        /**
         * Performs unescaping on the given property value.
         *
         * @param value the property value
         * @return the unescaped property value
         * @since 2.4
         */
        protected String unescapePropertyValue(String value)
        {
<span class="fc" id="L874">            return unescapeJava(value);</span>
        }

        /**
         * Sets the separator of the current property. This method can be called
         * by {@code parseProperty()}. It allows the associated layout
         * object to keep track of the property separators. When saving the
         * configuration the separators can be restored.
         *
         * @param value the separator used for the current property
         * @since 1.7
         */
        protected void initPropertySeparator(final String value)
        {
<span class="fc" id="L888">            propertySeparator = value;</span>
<span class="fc" id="L889">        }</span>

        /**
         * Checks if the passed in line should be combined with the following.
         * This is true, if the line ends with an odd number of backslashes.
         *
         * @param line the line
         * @return a flag if the lines should be combined
         */
        static boolean checkCombineLines(final String line)
        {
<span class="fc bfc" id="L900" title="All 2 branches covered.">            return countTrailingBS(line) % 2 != 0;</span>
        }

        /**
         * Parse a property line and return the key, the value, and the separator in an
         * array.
         *
         * @param line the line to parse
         * @param trimValue flag whether the value is to be trimmed
         * @return an array with the property's key, value, and separator
         */
        static String[] doParseProperty(final String line, final boolean trimValue)
        {
<span class="fc" id="L913">            final Matcher matcher = PROPERTY_PATTERN.matcher(line);</span>

<span class="fc" id="L915">            final String[] result = {&quot;&quot;, &quot;&quot;, &quot;&quot;};</span>

<span class="pc bpc" id="L917" title="1 of 2 branches missed.">            if (matcher.matches())</span>
            {
<span class="fc" id="L919">                result[0] = matcher.group(IDX_KEY).trim();</span>

<span class="fc" id="L921">                String value = matcher.group(IDX_VALUE);</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">                if (trimValue)</span>
                {
<span class="fc" id="L924">                    value = value.trim();</span>
                }
<span class="fc" id="L926">                result[1] = value;</span>

<span class="fc" id="L928">                result[2] = matcher.group(IDX_SEPARATOR);</span>
            }

<span class="fc" id="L931">            return result;</span>
        }
    } // class PropertiesReader

    /**
     * This class is used to write properties lines. The most important method
     * is {@code writeProperty(String, Object, boolean)}, which is called
     * during a save operation for each property found in the configuration.
     */
    public static class PropertiesWriter extends FilterWriter
    {

        /**
         * Properties escape map.
         */
        private static final Map&lt;CharSequence, CharSequence&gt; PROPERTIES_CHARS_ESCAPE;
        static
        {
<span class="fc" id="L949">            final Map&lt;CharSequence, CharSequence&gt; initialMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L950">            initialMap.put(&quot;\\&quot;, &quot;\\\\&quot;);</span>
<span class="fc" id="L951">            PROPERTIES_CHARS_ESCAPE = Collections.unmodifiableMap(initialMap);</span>
        }

        /**
         * A translator for escaping property values. This translator performs a
         * subset of transformations done by the ESCAPE_JAVA translator from
         * Commons Lang 3.
         */
<span class="fc" id="L959">        private static final CharSequenceTranslator ESCAPE_PROPERTIES =</span>
                new AggregateTranslator(
                        new LookupTranslator(PROPERTIES_CHARS_ESCAPE),
                        new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE),
<span class="fc" id="L963">                        UnicodeEscaper.outsideOf(32, 0x7f));</span>

        /**
         * A {@code ValueTransformer} implementation used to escape property
         * values. This implementation applies the transformation defined by the
         * {@link #ESCAPE_PROPERTIES} translator.
         */
<span class="fc" id="L970">        private static final ValueTransformer DEFAULT_TRANSFORMER =</span>
                new ValueTransformer()
<span class="fc" id="L972">                {</span>
                    @Override
                    public Object transformValue(final Object value)
                    {
<span class="fc" id="L976">                        final String strVal = String.valueOf(value);</span>
<span class="fc" id="L977">                        return ESCAPE_PROPERTIES.translate(strVal);</span>
                    }
                };

        /** The value transformer used for escaping property values. */
        private final ValueTransformer valueTransformer;

        /** The list delimiter handler.*/
        private final ListDelimiterHandler delimiterHandler;

        /** The separator to be used for the current property. */
        private String currentSeparator;

        /** The global separator. If set, it overrides the current separator.*/
        private String globalSeparator;

        /** The line separator.*/
        private String lineSeparator;

        /**
         * Creates a new instance of {@code PropertiesWriter}.
         *
         * @param writer a Writer object providing the underlying stream
         * @param delHandler the delimiter handler for dealing with properties
         *        with multiple values
         */
        public PropertiesWriter(final Writer writer, final ListDelimiterHandler delHandler)
        {
<span class="fc" id="L1005">            this(writer, delHandler, DEFAULT_TRANSFORMER);</span>
<span class="fc" id="L1006">        }</span>

        /**
         * Creates a new instance of {@code PropertiesWriter}.
         *
         * @param writer a Writer object providing the underlying stream
         * @param delHandler the delimiter handler for dealing with properties
         *        with multiple values
         * @param valueTransformer the value transformer used to escape property values
         */
        public PropertiesWriter(Writer writer, ListDelimiterHandler delHandler, ValueTransformer valueTransformer)
        {
<span class="fc" id="L1018">            super(writer);</span>
<span class="fc" id="L1019">            delimiterHandler = delHandler;</span>
<span class="fc" id="L1020">            this.valueTransformer = valueTransformer;</span>
<span class="fc" id="L1021">        }</span>

        /**
         * Returns the delimiter handler for properties with multiple values.
         * This object is used to escape property values so that they can be
         * read in correctly the next time they are loaded.
         *
         * @return the delimiter handler for properties with multiple values
         * @since 2.0
         */
        public ListDelimiterHandler getDelimiterHandler()
        {
<span class="fc" id="L1033">            return delimiterHandler;</span>
        }

        /**
         * Returns the current property separator.
         *
         * @return the current property separator
         * @since 1.7
         */
        public String getCurrentSeparator()
        {
<span class="fc" id="L1044">            return currentSeparator;</span>
        }

        /**
         * Sets the current property separator. This separator is used when
         * writing the next property.
         *
         * @param currentSeparator the current property separator
         * @since 1.7
         */
        public void setCurrentSeparator(final String currentSeparator)
        {
<span class="fc" id="L1056">            this.currentSeparator = currentSeparator;</span>
<span class="fc" id="L1057">        }</span>

        /**
         * Returns the global property separator.
         *
         * @return the global property separator
         * @since 1.7
         */
        public String getGlobalSeparator()
        {
<span class="fc" id="L1067">            return globalSeparator;</span>
        }

        /**
         * Sets the global property separator. This separator corresponds to the
         * {@code globalSeparator} property of
         * {@link PropertiesConfigurationLayout}. It defines the separator to be
         * used for all properties. If it is undefined, the current separator is
         * used.
         *
         * @param globalSeparator the global property separator
         * @since 1.7
         */
        public void setGlobalSeparator(final String globalSeparator)
        {
<span class="fc" id="L1082">            this.globalSeparator = globalSeparator;</span>
<span class="fc" id="L1083">        }</span>

        /**
         * Returns the line separator.
         *
         * @return the line separator
         * @since 1.7
         */
        public String getLineSeparator()
        {
<span class="fc bfc" id="L1093" title="All 2 branches covered.">            return (lineSeparator != null) ? lineSeparator : LINE_SEPARATOR;</span>
        }

        /**
         * Sets the line separator. Each line written by this writer is
         * terminated with this separator. If not set, the platform-specific
         * line separator is used.
         *
         * @param lineSeparator the line separator to be used
         * @since 1.7
         */
        public void setLineSeparator(final String lineSeparator)
        {
<span class="fc" id="L1106">            this.lineSeparator = lineSeparator;</span>
<span class="fc" id="L1107">        }</span>

        /**
         * Write a property.
         *
         * @param key the key of the property
         * @param value the value of the property
         *
         * @throws IOException if an I/O error occurs
         */
        public void writeProperty(final String key, final Object value) throws IOException
        {
<span class="fc" id="L1119">            writeProperty(key, value, false);</span>
<span class="fc" id="L1120">        }</span>

        /**
         * Write a property.
         *
         * @param key The key of the property
         * @param values The array of values of the property
         *
         * @throws IOException if an I/O error occurs
         */
        public void writeProperty(final String key, final List&lt;?&gt; values) throws IOException
        {
<span class="fc bfc" id="L1132" title="All 2 branches covered.">            for (int i = 0; i &lt; values.size(); i++)</span>
            {
<span class="fc" id="L1134">                writeProperty(key, values.get(i));</span>
            }
<span class="fc" id="L1136">        }</span>

        /**
         * Writes the given property and its value. If the value happens to be a
         * list, the {@code forceSingleLine} flag is evaluated. If it is
         * set, all values are written on a single line using the list delimiter
         * as separator.
         *
         * @param key the property key
         * @param value the property value
         * @param forceSingleLine the &amp;quot;force single line&amp;quot; flag
         * @throws IOException if an error occurs
         * @since 1.3
         */
        public void writeProperty(final String key, final Object value,
                final boolean forceSingleLine) throws IOException
        {
            String v;

<span class="fc bfc" id="L1155" title="All 2 branches covered.">            if (value instanceof List)</span>
            {
<span class="fc" id="L1157">                v = null;</span>
<span class="fc" id="L1158">                final List&lt;?&gt; values = (List&lt;?&gt;) value;</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">                if (forceSingleLine)</span>
                {
                    try
                    {
<span class="fc" id="L1163">                        v = String.valueOf(getDelimiterHandler()</span>
<span class="fc" id="L1164">                                        .escapeList(values, valueTransformer));</span>
                    }
<span class="fc" id="L1166">                    catch (final UnsupportedOperationException uoex)</span>
                    {
                        // the handler may not support escaping lists,
                        // then the list is written in multiple lines
<span class="fc" id="L1170">                    }</span>
                }
<span class="fc bfc" id="L1172" title="All 2 branches covered.">                if (v == null)</span>
                {
<span class="fc" id="L1174">                    writeProperty(key, values);</span>
<span class="fc" id="L1175">                    return;</span>
                }
<span class="fc" id="L1177">            }</span>
            else
            {
<span class="fc" id="L1180">                v = String.valueOf(getDelimiterHandler().escape(value, valueTransformer));</span>
            }

<span class="fc" id="L1183">            write(escapeKey(key));</span>
<span class="fc" id="L1184">            write(fetchSeparator(key, value));</span>
<span class="fc" id="L1185">            write(v);</span>

<span class="fc" id="L1187">            writeln(null);</span>
<span class="fc" id="L1188">        }</span>

        /**
         * Write a comment.
         *
         * @param comment the comment to write
         * @throws IOException if an I/O error occurs
         */
        public void writeComment(final String comment) throws IOException
        {
<span class="nc" id="L1198">            writeln(&quot;# &quot; + comment);</span>
<span class="nc" id="L1199">        }</span>

        /**
         * Escapes the key of a property before it gets written to file. This
         * method is called on saving a configuration for each property key.
         * It ensures that separator characters contained in the key are
         * escaped.
         *
         * @param key the key
         * @return the escaped key
         * @since 2.0
         */
        protected String escapeKey(final String key)
        {
<span class="fc" id="L1213">            final StringBuilder newkey = new StringBuilder();</span>

<span class="fc bfc" id="L1215" title="All 2 branches covered.">            for (int i = 0; i &lt; key.length(); i++)</span>
            {
<span class="fc" id="L1217">                final char c = key.charAt(i);</span>

<span class="pc bpc" id="L1219" title="1 of 6 branches missed.">                if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c) ||</span>
                        c == '\\')
                {
                    // escape the separator
<span class="fc" id="L1223">                    newkey.append('\\');</span>
<span class="fc" id="L1224">                    newkey.append(c);</span>
                }
                else
                {
<span class="fc" id="L1228">                    newkey.append(c);</span>
                }
            }

<span class="fc" id="L1232">            return newkey.toString();</span>
        }

        /**
         * Helper method for writing a line with the platform specific line
         * ending.
         *
         * @param s the content of the line (may be &lt;b&gt;null&lt;/b&gt;)
         * @throws IOException if an error occurs
         * @since 1.3
         */
        public void writeln(final String s) throws IOException
        {
<span class="fc bfc" id="L1245" title="All 2 branches covered.">            if (s != null)</span>
            {
<span class="fc" id="L1247">                write(s);</span>
            }
<span class="fc" id="L1249">            write(getLineSeparator());</span>
<span class="fc" id="L1250">        }</span>

        /**
         * Returns the separator to be used for the given property. This method
         * is called by {@code writeProperty()}. The string returned here
         * is used as separator between the property key and its value. Per
         * default the method checks whether a global separator is set. If this
         * is the case, it is returned. Otherwise the separator returned by
         * {@code getCurrentSeparator()} is used, which was set by the
         * associated layout object. Derived classes may implement a different
         * strategy for defining the separator.
         *
         * @param key the property key
         * @param value the value
         * @return the separator to be used
         * @since 1.7
         */
        protected String fetchSeparator(final String key, final Object value)
        {
<span class="fc bfc" id="L1269" title="All 2 branches covered.">            return (getGlobalSeparator() != null) ? getGlobalSeparator()</span>
<span class="fc" id="L1270">                    : StringUtils.defaultString(getCurrentSeparator());</span>
        }
    } // class PropertiesWriter

    /**
     * &lt;p&gt;
     * Definition of an interface that allows customization of read and write
     * operations.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For reading and writing properties files the inner classes
     * {@code PropertiesReader} and {@code PropertiesWriter} are used.
     * This interface defines factory methods for creating both a
     * {@code PropertiesReader} and a {@code PropertiesWriter}. An
     * object implementing this interface can be passed to the
     * {@code setIOFactory()} method of
     * {@code PropertiesConfiguration}. Every time the configuration is
     * read or written the {@code IOFactory} is asked to create the
     * appropriate reader or writer object. This provides an opportunity to
     * inject custom reader or writer implementations.
     * &lt;/p&gt;
     *
     * @since 1.7
     */
    public interface IOFactory
    {
        /**
         * Creates a {@code PropertiesReader} for reading a properties
         * file. This method is called whenever the
         * {@code PropertiesConfiguration} is loaded. The reader returned
         * by this method is then used for parsing the properties file.
         *
         * @param in the underlying reader (of the properties file)
         * @return the {@code PropertiesReader} for loading the
         *         configuration
         */
        PropertiesReader createPropertiesReader(Reader in);

        /**
         * Creates a {@code PropertiesWriter} for writing a properties
         * file. This method is called before the
         * {@code PropertiesConfiguration} is saved. The writer returned by
         * this method is then used for writing the properties file.
         *
         * @param out the underlying writer (to the properties file)
         * @param handler the list delimiter delimiter for list parsing
         * @return the {@code PropertiesWriter} for saving the
         *         configuration
         */
        PropertiesWriter createPropertiesWriter(Writer out,
                ListDelimiterHandler handler);
    }

    /**
     * &lt;p&gt;
     * A default implementation of the {@code IOFactory} interface.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This class implements the {@code createXXXX()} methods defined by
     * the {@code IOFactory} interface in a way that the default objects
     * (i.e. {@code PropertiesReader} and {@code PropertiesWriter} are
     * returned. Customizing either the reader or the writer (or both) can be
     * done by extending this class and overriding the corresponding
     * {@code createXXXX()} method.
     * &lt;/p&gt;
     *
     * @since 1.7
     */
<span class="fc" id="L1338">    public static class DefaultIOFactory implements IOFactory</span>
    {
        @Override
        public PropertiesReader createPropertiesReader(final Reader in)
        {
<span class="fc" id="L1343">            return new PropertiesReader(in);</span>
        }

        @Override
        public PropertiesWriter createPropertiesWriter(final Writer out,
                final ListDelimiterHandler handler)
        {
<span class="fc" id="L1350">            return new PropertiesWriter(out, handler);</span>
        }
    }

    /**
     * An alternative {@link IOFactory} that tries to mimic the behavior of
     * {@link java.util.Properties} (Jup) more closely. The goal is to allow both of
     * them be used interchangeably when reading and writing properties files
     * without losing or changing information.
     * &lt;p&gt;
     * It also has the option to &lt;em&gt;not&lt;/em&gt; use Unicode escapes. When using UTF-8
     * encoding (which is e.g. the new default for resource bundle properties files
     * since Java 9), Unicode escapes are no longer required and avoiding them makes
     * properties files more readable with regular text editors.
     * &lt;p&gt;
     * Some of the ways this implementation differs from {@link DefaultIOFactory}:
     * &lt;ul&gt;
     * &lt;li&gt;Trailing whitespace will not be trimmed from each line.&lt;/li&gt;
     * &lt;li&gt;Unknown escape sequences will have their backslash removed.&lt;/li&gt;
     * &lt;li&gt;{@code \b} is not a recognized escape sequence.&lt;/li&gt;
     * &lt;li&gt;Leading spaces in property values are preserved by escaping them.&lt;/li&gt;
     * &lt;li&gt;All natural lines (i.e. in the file) of a logical property line will have
     * their leading whitespace trimmed.&lt;/li&gt;
     * &lt;li&gt;Natural lines that look like comment lines within a logical line are not
     * treated as such; they're part of the property value.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @since 2.4
     */
    public static class JupIOFactory implements IOFactory
    {

        /**
         * Whether characters less than {@code \u0020} and characters greater than
         * {@code \u007E} in property keys or values should be escaped using
         * Unicode escape sequences. Not necessary when e.g. writing as UTF-8.
         */
        private final boolean escapeUnicode;

        /**
         * Constructs a new {@link JupIOFactory} with Unicode escaping.
         */
        public JupIOFactory()
        {
<span class="fc" id="L1394">            this(true);</span>
<span class="fc" id="L1395">        }</span>

        /**
         * Constructs a new {@link JupIOFactory} with optional Unicode escaping. Whether
         * Unicode escaping is required depends on the encoding used to save the
         * properties file. E.g. for ISO-8859-1 this must be turned on, for UTF-8 it's
         * not necessary. Unfortunately this factory can't determine the encoding on its
         * own.
         *
         * @param escapeUnicode whether Unicode characters should be escaped
         */
        public JupIOFactory(boolean escapeUnicode)
<span class="fc" id="L1407">        {</span>
<span class="fc" id="L1408">            this.escapeUnicode = escapeUnicode;</span>
<span class="fc" id="L1409">        }</span>

        @Override
        public PropertiesReader createPropertiesReader(Reader in)
        {
<span class="fc" id="L1414">            return new JupPropertiesReader(in);</span>
        }

        @Override
        public PropertiesWriter createPropertiesWriter(Writer out, ListDelimiterHandler handler)
        {
<span class="fc" id="L1420">            return new JupPropertiesWriter(out, handler, escapeUnicode);</span>
        }

    }

    /**
     * A {@link PropertiesReader} that tries to mimic the behavior of
     * {@link java.util.Properties}.
     *
     * @since 2.4
     */
    public static class JupPropertiesReader extends PropertiesReader
    {

        /**
         * Constructor.
         *
         * @param reader A Reader.
         */
        public JupPropertiesReader(Reader reader)
        {
<span class="fc" id="L1441">            super(reader);</span>
<span class="fc" id="L1442">        }</span>


        @Override
        public String readProperty() throws IOException
        {
<span class="fc" id="L1448">            getCommentLines().clear();</span>
<span class="fc" id="L1449">            StringBuilder buffer = new StringBuilder();</span>

            while (true)
            {
<span class="fc" id="L1453">                String line = readLine();</span>
<span class="fc bfc" id="L1454" title="All 2 branches covered.">                if (line == null)</span>
                {
                    // EOF
<span class="pc bpc" id="L1457" title="1 of 2 branches missed.">                    if (buffer.length() &gt; 0)</span>
                    {
<span class="nc" id="L1459">                        break;</span>
                    }
<span class="fc" id="L1461">                    return null;</span>
                }

                // while a property line continues there are no comments (even if the line from
                // the file looks like one)
<span class="fc bfc" id="L1466" title="All 4 branches covered.">                if (isCommentLine(line) &amp;&amp; (buffer.length() == 0))</span>
                {
<span class="fc" id="L1468">                    getCommentLines().add(line);</span>
<span class="fc" id="L1469">                    continue;</span>
                }

                // while property line continues left trim all following lines read from the
                // file
<span class="fc bfc" id="L1474" title="All 2 branches covered.">                if (buffer.length() &gt; 0)</span>
                {
                    // index of the first non-whitespace character
                    int i;
<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">                    for (i = 0; i &lt; line.length(); i++)</span>
                    {
<span class="fc bfc" id="L1480" title="All 2 branches covered.">                        if (!Character.isWhitespace(line.charAt(i)))</span>
                        {
<span class="fc" id="L1482">                            break;</span>
                        }
                    }

<span class="fc" id="L1486">                    line = line.substring(i);</span>
                }

<span class="fc bfc" id="L1489" title="All 2 branches covered.">                if (checkCombineLines(line))</span>
                {
<span class="fc" id="L1491">                    line = line.substring(0, line.length() - 1);</span>
<span class="fc" id="L1492">                    buffer.append(line);</span>
                }
                else
                {
<span class="fc" id="L1496">                    buffer.append(line);</span>
<span class="fc" id="L1497">                    break;</span>
                }
<span class="fc" id="L1499">            }</span>
<span class="fc" id="L1500">            return buffer.toString();</span>
        }

        @Override
        protected void parseProperty(String line)
        {
<span class="fc" id="L1506">            String[] property = doParseProperty(line, false);</span>
<span class="fc" id="L1507">            initPropertyName(property[0]);</span>
<span class="fc" id="L1508">            initPropertyValue(property[1]);</span>
<span class="fc" id="L1509">            initPropertySeparator(property[2]);</span>
<span class="fc" id="L1510">        }</span>

        @Override
        protected String unescapePropertyValue(String value)
        {
<span class="fc" id="L1515">            return unescapeJava(value, true);</span>
        }

    }

    /**
     * A {@link PropertiesWriter} that tries to mimic the behavior of
     * {@link java.util.Properties}.
     *
     * @since 2.4
     */
    public static class JupPropertiesWriter extends PropertiesWriter
    {

        /**
         * Characters that need to be escaped when wring a properties file.
         */
        private static final Map&lt;CharSequence, CharSequence&gt; JUP_CHARS_ESCAPE;
        static
        {
<span class="fc" id="L1535">            Map&lt;CharSequence, CharSequence&gt; initialMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1536">            initialMap.put(&quot;\\&quot;, &quot;\\\\&quot;);</span>
<span class="fc" id="L1537">            initialMap.put(&quot;\n&quot;, &quot;\\n&quot;);</span>
<span class="fc" id="L1538">            initialMap.put(&quot;\t&quot;, &quot;\\t&quot;);</span>
<span class="fc" id="L1539">            initialMap.put(&quot;\f&quot;, &quot;\\f&quot;);</span>
<span class="fc" id="L1540">            initialMap.put(&quot;\r&quot;, &quot;\\r&quot;);</span>
<span class="fc" id="L1541">            JUP_CHARS_ESCAPE = Collections.unmodifiableMap(initialMap);</span>
<span class="fc" id="L1542">        };</span>

        /**
         * Creates a new instance of {@code JupPropertiesWriter}.
         *
         * @param writer a Writer object providing the underlying stream
         * @param delHandler the delimiter handler for dealing with properties with
         *        multiple values
         * @param escapeUnicode whether Unicode characters should be escaped using
         *        Unicode escapes
         */
        public JupPropertiesWriter(Writer writer, ListDelimiterHandler delHandler, final boolean escapeUnicode)
        {
<span class="fc" id="L1555">            super(writer, delHandler, new ValueTransformer()</span>
<span class="fc" id="L1556">            {</span>
                @Override
                public Object transformValue(Object value)
                {
<span class="fc" id="L1560">                    String valueString = String.valueOf(value);</span>

                    CharSequenceTranslator translator;
<span class="fc bfc" id="L1563" title="All 2 branches covered.">                    if (escapeUnicode)</span>
                    {
<span class="fc" id="L1565">                        translator = new AggregateTranslator(new LookupTranslator(JUP_CHARS_ESCAPE),</span>
<span class="fc" id="L1566">                                UnicodeEscaper.outsideOf(0x20, 0x7e));</span>
                    }
                    else
                    {
<span class="fc" id="L1570">                        translator = new AggregateTranslator(new LookupTranslator(JUP_CHARS_ESCAPE));</span>
                    }

<span class="fc" id="L1573">                    valueString = translator.translate(valueString);</span>

                    // escape the first leading space to preserve it (and all after it)
<span class="fc bfc" id="L1576" title="All 2 branches covered.">                    if (valueString.startsWith(&quot; &quot;))</span>
                    {
<span class="fc" id="L1578">                        valueString = &quot;\\&quot; + valueString;</span>
                    }

<span class="fc" id="L1581">                    return valueString;</span>
                }
            });
<span class="fc" id="L1584">        }</span>

    }

    /**
     * &lt;p&gt;Unescapes any Java literals found in the {@code String} to a
     * {@code Writer}.&lt;/p&gt; This is a slightly modified version of the
     * StringEscapeUtils.unescapeJava() function in commons-lang that doesn't
     * drop escaped separators (i.e '\,').
     *
     * @param str  the {@code String} to unescape, may be null
     * @return the processed string
     * @throws IllegalArgumentException if the Writer is {@code null}
     */
    protected static String unescapeJava(final String str)
    {
<span class="fc" id="L1600">        return unescapeJava(str, false);</span>
    }

    /**
     * Unescapes Java literals found in the {@code String} to a {@code Writer}.
     * &lt;/p&gt;
     * When the parameter {@code jupCompatible} is {@code false}, the classic
     * behavior is used (see {@link #unescapeJava(String)}). When it's {@code true}
     * a slightly different behavior that's compatible with
     * {@link java.util.Properties} is used (see {@link JupIOFactory}).
     *
     * @param str the {@code String} to unescape, may be null
     * @param jupCompatible whether unescaping is compatible with
     *        {@link java.util.Properties}; otherwise the classic behavior is used
     * @return the processed string
     * @throws IllegalArgumentException if the Writer is {@code null}
     */
    protected static String unescapeJava(String str, boolean jupCompatible)
    {
<span class="pc bpc" id="L1619" title="1 of 2 branches missed.">        if (str == null)</span>
        {
<span class="nc" id="L1621">            return null;</span>
        }
<span class="fc" id="L1623">        final int sz = str.length();</span>
<span class="fc" id="L1624">        final StringBuilder out = new StringBuilder(sz);</span>
<span class="fc" id="L1625">        final StringBuilder unicode = new StringBuilder(UNICODE_LEN);</span>
<span class="fc" id="L1626">        boolean hadSlash = false;</span>
<span class="fc" id="L1627">        boolean inUnicode = false;</span>
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++)</span>
        {
<span class="fc" id="L1630">            final char ch = str.charAt(i);</span>
<span class="fc bfc" id="L1631" title="All 2 branches covered.">            if (inUnicode)</span>
            {
                // if in unicode, then we're reading unicode
                // values in somehow
<span class="fc" id="L1635">                unicode.append(ch);</span>
<span class="fc bfc" id="L1636" title="All 2 branches covered.">                if (unicode.length() == UNICODE_LEN)</span>
                {
                    // unicode now contains the four hex digits
                    // which represents our unicode character
                    try
                    {
<span class="fc" id="L1642">                        final int value = Integer.parseInt(unicode.toString(), HEX_RADIX);</span>
<span class="fc" id="L1643">                        out.append((char) value);</span>
<span class="fc" id="L1644">                        unicode.setLength(0);</span>
<span class="fc" id="L1645">                        inUnicode = false;</span>
<span class="fc" id="L1646">                        hadSlash = false;</span>
                    }
<span class="nc" id="L1648">                    catch (final NumberFormatException nfe)</span>
                    {
<span class="nc" id="L1650">                        throw new ConfigurationRuntimeException(&quot;Unable to parse unicode value: &quot; + unicode, nfe);</span>
<span class="fc" id="L1651">                    }</span>
                }
                continue;
            }

<span class="fc bfc" id="L1656" title="All 2 branches covered.">            if (hadSlash)</span>
            {
                // handle an escaped value
<span class="fc" id="L1659">                hadSlash = false;</span>

<span class="pc bpc" id="L1661" title="1 of 2 branches missed.">                if (ch == 'r')</span>
                {
<span class="nc" id="L1663">                    out.append('\r');</span>
                }
<span class="pc bpc" id="L1665" title="1 of 2 branches missed.">                else if (ch == 'f')</span>
                {
<span class="nc" id="L1667">                    out.append('\f');</span>
                }
<span class="fc bfc" id="L1669" title="All 2 branches covered.">                else if (ch == 't')</span>
                {
<span class="fc" id="L1671">                    out.append('\t');</span>
                }
<span class="fc bfc" id="L1673" title="All 2 branches covered.">                else if (ch == 'n')</span>
                {
<span class="fc" id="L1675">                    out.append('\n');</span>
                }
                // JUP does not recognize \b
<span class="pc bpc" id="L1678" title="1 of 4 branches missed.">                else if (!jupCompatible &amp;&amp; ch == 'b')</span>
                {
<span class="nc" id="L1680">                    out.append('\b');</span>
                }
<span class="fc bfc" id="L1682" title="All 2 branches covered.">                else if (ch == 'u')</span>
                {
                    // uh-oh, we're in unicode country....
<span class="fc" id="L1685">                    inUnicode = true;</span>
                }
<span class="fc bfc" id="L1687" title="All 2 branches covered.">                else if (needsUnescape(ch))</span>
                {
<span class="fc" id="L1689">                    out.append(ch);</span>
                }
                else
                {
                    // JUP simply throws away the \ of unknown escape sequences
<span class="fc bfc" id="L1694" title="All 2 branches covered.">                    if (!jupCompatible)</span>
                    {
<span class="fc" id="L1696">                        out.append('\\');</span>
                    }
<span class="fc" id="L1698">                    out.append(ch);</span>
                }

<span class="fc" id="L1701">                continue;</span>
            }
<span class="fc bfc" id="L1703" title="All 2 branches covered.">            else if (ch == '\\')</span>
            {
<span class="fc" id="L1705">                hadSlash = true;</span>
<span class="fc" id="L1706">                continue;</span>
            }
<span class="fc" id="L1708">            out.append(ch);</span>
        }

<span class="pc bpc" id="L1711" title="1 of 2 branches missed.">        if (hadSlash)</span>
        {
            // then we're in the weird case of a \ at the end of the
            // string, let's output it anyway.
<span class="nc" id="L1715">            out.append('\\');</span>
        }

<span class="fc" id="L1718">        return out.toString();</span>
    }

    /**
     * Checks whether the specified character needs to be unescaped. This method
     * is called when during reading a property file an escape character ('\')
     * is detected. If the character following the escape character is
     * recognized as a special character which is escaped per default in a Java
     * properties file, it has to be unescaped.
     *
     * @param ch the character in question
     * @return a flag whether this character has to be unescaped
     */
    private static boolean needsUnescape(final char ch)
    {
<span class="fc bfc" id="L1733" title="All 2 branches covered.">        return UNESCAPE_CHARACTERS.indexOf(ch) &gt;= 0;</span>
    }

    /**
     * Helper method for loading an included properties file. This method is
     * called by {@code load()} when an {@code include} property
     * is encountered. It tries to resolve relative file names based on the
     * current base path. If this fails, a resolution based on the location of
     * this properties file is tried.
     *
     * @param fileName the name of the file to load
     * @throws ConfigurationException if loading fails
     */
    private void loadIncludeFile(final String fileName) throws ConfigurationException
    {
<span class="fc bfc" id="L1748" title="All 2 branches covered.">        if (locator == null)</span>
        {
<span class="fc" id="L1750">            throw new ConfigurationException(&quot;Load operation not properly &quot;</span>
                    + &quot;initialized! Do not call read(InputStream) directly,&quot;
                    + &quot; but use a FileHandler to load a configuration.&quot;);
        }

<span class="fc" id="L1755">        URL url = locateIncludeFile(locator.getBasePath(), fileName);</span>
<span class="fc bfc" id="L1756" title="All 2 branches covered.">        if (url == null)</span>
        {
<span class="fc" id="L1758">            final URL baseURL = locator.getSourceURL();</span>
<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">            if (baseURL != null)</span>
            {
<span class="fc" id="L1761">                url = locateIncludeFile(baseURL.toString(), fileName);</span>
            }
        }

<span class="fc bfc" id="L1765" title="All 2 branches covered.">        if (url == null)</span>
        {
<span class="fc" id="L1767">            throw new ConfigurationException(&quot;Cannot resolve include file &quot;</span>
                    + fileName);
        }

<span class="fc" id="L1771">        final FileHandler fh = new FileHandler(this);</span>
<span class="fc" id="L1772">        fh.setFileLocator(locator);</span>
<span class="fc" id="L1773">        final FileLocator orgLocator = locator;</span>
        try
        {
<span class="fc" id="L1776">            fh.load(url);</span>
        }
        finally
        {
<span class="pc" id="L1780">            locator = orgLocator; // reset locator which is changed by load</span>
<span class="pc" id="L1781">        }</span>
<span class="fc" id="L1782">    }</span>

    /**
     * Tries to obtain the URL of an include file using the specified (optional)
     * base path and file name.
     *
     * @param basePath the base path
     * @param fileName the file name
     * @return the URL of the include file or &lt;b&gt;null&lt;/b&gt; if it cannot be
     *         resolved
     */
    private URL locateIncludeFile(final String basePath, final String fileName)
    {
<span class="fc" id="L1795">        final FileLocator includeLocator =</span>
<span class="fc" id="L1796">                FileLocatorUtils.fileLocator(locator).sourceURL(null)</span>
<span class="fc" id="L1797">                        .basePath(basePath).fileName(fileName).create();</span>
<span class="fc" id="L1798">        return FileLocatorUtils.locate(includeLocator);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>