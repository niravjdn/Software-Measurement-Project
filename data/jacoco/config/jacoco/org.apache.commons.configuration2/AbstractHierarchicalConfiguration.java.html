<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractHierarchicalConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2</a> &gt; <span class="el_source">AbstractHierarchicalConfiguration.java</span></div><h1>AbstractHierarchicalConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.configuration2;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;
import org.apache.commons.configuration2.sync.NoOpSynchronizer;
import org.apache.commons.configuration2.tree.ConfigurationNodeVisitorAdapter;
import org.apache.commons.configuration2.tree.DefaultExpressionEngine;
import org.apache.commons.configuration2.tree.ExpressionEngine;
import org.apache.commons.configuration2.tree.NodeAddData;
import org.apache.commons.configuration2.tree.NodeHandler;
import org.apache.commons.configuration2.tree.NodeKeyResolver;
import org.apache.commons.configuration2.tree.NodeModel;
import org.apache.commons.configuration2.tree.NodeTreeWalker;
import org.apache.commons.configuration2.tree.NodeUpdateData;
import org.apache.commons.configuration2.tree.QueryResult;

/**
 * &lt;p&gt;
 * A specialized configuration class that extends its base class by the ability
 * of keeping more structure in the stored properties.
 * &lt;/p&gt;
 * &lt;p&gt;
 * There are some sources of configuration data that cannot be stored very well
 * in a {@code BaseConfiguration} object because then their structure is lost.
 * This is for instance true for XML documents. This class can deal with such
 * structured configuration sources by storing the properties in a tree-like
 * organization. The exact storage structure of the underlying data does not
 * matter for the configuration instance; it uses a {@link NodeModel} object for
 * accessing it.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The hierarchical organization allows for a more sophisticated access to
 * single properties. As an example consider the following XML document:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;database&amp;gt;
 *   &amp;lt;tables&amp;gt;
 *     &amp;lt;table&amp;gt;
 *       &amp;lt;name&amp;gt;users&amp;lt;/name&amp;gt;
 *       &amp;lt;fields&amp;gt;
 *         &amp;lt;field&amp;gt;
 *           &amp;lt;name&amp;gt;lid&amp;lt;/name&amp;gt;
 *           &amp;lt;type&amp;gt;long&amp;lt;/name&amp;gt;
 *         &amp;lt;/field&amp;gt;
 *         &amp;lt;field&amp;gt;
 *           &amp;lt;name&amp;gt;usrName&amp;lt;/name&amp;gt;
 *           &amp;lt;type&amp;gt;java.lang.String&amp;lt;/type&amp;gt;
 *         &amp;lt;/field&amp;gt;
 *        ...
 *       &amp;lt;/fields&amp;gt;
 *     &amp;lt;/table&amp;gt;
 *     &amp;lt;table&amp;gt;
 *       &amp;lt;name&amp;gt;documents&amp;lt;/name&amp;gt;
 *       &amp;lt;fields&amp;gt;
 *         &amp;lt;field&amp;gt;
 *           &amp;lt;name&amp;gt;docid&amp;lt;/name&amp;gt;
 *           &amp;lt;type&amp;gt;long&amp;lt;/type&amp;gt;
 *         &amp;lt;/field&amp;gt;
 *         ...
 *       &amp;lt;/fields&amp;gt;
 *     &amp;lt;/table&amp;gt;
 *     ...
 *   &amp;lt;/tables&amp;gt;
 * &amp;lt;/database&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If this document is parsed and stored in a hierarchical configuration object
 * (which can be done by one of the sub classes), there are enhanced
 * possibilities of accessing properties. Per default, the keys for querying
 * information can contain indices that select a specific element if there are
 * multiple hits.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For instance the key {@code tables.table(0).name} can be used to find out the
 * name of the first table. In opposite {@code tables.table.name} would return a
 * collection with the names of all available tables. Similarly the key
 * {@code tables.table(1).fields.field.name} returns a collection with the names
 * of all fields of the second table. If another index is added after the
 * {@code field} element, a single field can be accessed:
 * {@code tables.table(1).fields.field(0).name}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * There is a {@code getMaxIndex()} method that returns the maximum allowed
 * index that can be added to a given property key. This method can be used to
 * iterate over all values defined for a certain property.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Since the 1.3 release of &lt;em&gt;Commons Configuration&lt;/em&gt; hierarchical
 * configurations support an &lt;em&gt;expression engine&lt;/em&gt;. This expression engine
 * is responsible for evaluating the passed in configuration keys and map them
 * to the stored properties. The examples above are valid for the default
 * expression engine, which is used when a new
 * {@code AbstractHierarchicalConfiguration} instance is created. With the
 * {@code setExpressionEngine()} method a different expression engine can be
 * set. For instance with
 * {@link org.apache.commons.configuration2.tree.xpath.XPathExpressionEngine}
 * there is an expression engine available that supports configuration keys in
 * XPATH syntax.
 * &lt;/p&gt;
 * &lt;p&gt;
 * In addition to the events common for all configuration classes, hierarchical
 * configurations support some more events that correspond to some specific
 * methods and features. For those events specific event type constants in
 * {@code ConfigurationEvent} exist:
 * &lt;/p&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;em&gt;ADD_NODES&lt;/em&gt;&lt;/dt&gt;
 * &lt;dd&gt;The {@code addNodes()} method was called; the event object contains the
 * key, to which the nodes were added, and a collection with the new nodes as
 * value.&lt;/dd&gt;
 * &lt;dt&gt;&lt;em&gt;CLEAR_TREE&lt;/em&gt;&lt;/dt&gt;
 * &lt;dd&gt;The {@code clearTree()} method was called; the event object stores the
 * key of the removed sub tree.&lt;/dd&gt;
 * &lt;dt&gt;&lt;em&gt;SUBNODE_CHANGED&lt;/em&gt;&lt;/dt&gt;
 * &lt;dd&gt;A {@code SubnodeConfiguration} that was created from this configuration
 * has been changed. The value property of the event object contains the
 * original event object as it was sent by the subnode configuration.&lt;/dd&gt;
 * &lt;/dl&gt;
 * &lt;p&gt;
 * Whether an {@code AbstractHierarchicalConfiguration} object is thread-safe or
 * not depends on the underlying {@code NodeModel} and the
 * {@link org.apache.commons.configuration2.sync.Synchronizer Synchronizer}
 * it is associated with. Some {@code NodeModel} implementations are inherently
 * thread-safe; they do not require a special {@code Synchronizer}. (Per
 * default, a dummy {@code Synchronizer} is used which is not thread-safe!) The
 * methods for querying or updating configuration data invoke this
 * {@code Synchronizer} accordingly. When accessing the configuration's root
 * node directly, the client application is responsible for proper
 * synchronization. This is achieved by calling the methods
 * {@link #lock(org.apache.commons.configuration2.sync.LockMode) lock()},
 * and {@link #unlock(org.apache.commons.configuration2.sync.LockMode) unlock()} with a proper
 * {@link org.apache.commons.configuration2.sync.LockMode LockMode} argument.
 * In any case, it is recommended to not access the
 * root node directly, but to use corresponding methods for querying or updating
 * configuration data instead. Direct manipulations of a configuration's node
 * structure circumvent many internal mechanisms and thus can cause undesired
 * effects. For concrete subclasses dealing with specific node structures, this
 * situation may be different.
 * &lt;/p&gt;
 *
 * @version $Id$
 * @since 2.0
 * @param &lt;T&gt; the type of the nodes managed by this hierarchical configuration
 */
public abstract class AbstractHierarchicalConfiguration&lt;T&gt; extends AbstractConfiguration
    implements Cloneable, NodeKeyResolver&lt;T&gt;, HierarchicalConfiguration&lt;T&gt;
{
    /** The model for managing the data stored in this configuration. */
    private NodeModel&lt;T&gt; model;

    /** Stores the expression engine for this instance.*/
    private ExpressionEngine expressionEngine;

    /**
     * Creates a new instance of {@code AbstractHierarchicalConfiguration} and
     * sets the {@code NodeModel} to be used.
     *
     * @param nodeModel the {@code NodeModel}
     */
    protected AbstractHierarchicalConfiguration(final NodeModel&lt;T&gt; nodeModel)
<span class="fc" id="L192">    {</span>
<span class="fc" id="L193">        model = nodeModel;</span>
<span class="fc" id="L194">    }</span>

    /**
     * {@inheritDoc} This implementation handles synchronization and delegates
     * to {@code getRootElementNameInternal()}.
     */
    @Override
    public final String getRootElementName()
    {
<span class="fc" id="L203">        beginRead(false);</span>
        try
        {
<span class="fc" id="L206">            return getRootElementNameInternal();</span>
        }
        finally
        {
<span class="pc" id="L210">            endRead();</span>
<span class="nc" id="L211">        }</span>
    }

    /**
     * Actually obtains the name of the root element. This method is called by
     * {@code getRootElementName()}. It just returns the name of the root node.
     * Subclasses that treat the root element name differently can override this
     * method.
     *
     * @return the name of this configuration's root element
     */
    protected String getRootElementNameInternal()
    {
<span class="fc" id="L224">        final NodeHandler&lt;T&gt; nodeHandler = getModel().getNodeHandler();</span>
<span class="fc" id="L225">        return nodeHandler.nodeName(nodeHandler.getRootNode());</span>
    }

    /**
     * {@inheritDoc} This implementation returns the configuration's
     * {@code NodeModel}. It is guarded by the current {@code Synchronizer}.
     */
    @Override
    public NodeModel&lt;T&gt; getNodeModel()
    {
<span class="fc" id="L235">        beginRead(false);</span>
        try
        {
<span class="fc" id="L238">            return getModel();</span>
        }
        finally
        {
<span class="fc" id="L242">            endRead();</span>
<span class="fc" id="L243">        }</span>
    }

    /**
     * Returns the expression engine used by this configuration. This method
     * will never return &lt;b&gt;null&lt;/b&gt;; if no specific expression engine was set,
     * the default expression engine will be returned.
     *
     * @return the current expression engine
     * @since 1.3
     */
    @Override
    public ExpressionEngine getExpressionEngine()
    {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        return (expressionEngine != null) ? expressionEngine</span>
                : DefaultExpressionEngine.INSTANCE;
    }

    /**
     * Sets the expression engine to be used by this configuration. All property
     * keys this configuration has to deal with will be interpreted by this
     * engine.
     *
     * @param expressionEngine the new expression engine; can be &lt;b&gt;null&lt;/b&gt;,
     * then the default expression engine will be used
     * @since 1.3
     */
    @Override
    public void setExpressionEngine(final ExpressionEngine expressionEngine)
    {
<span class="fc" id="L273">        this.expressionEngine = expressionEngine;</span>
<span class="fc" id="L274">    }</span>

    /**
     * Fetches the specified property. This task is delegated to the associated
     * expression engine.
     *
     * @param key the key to be looked up
     * @return the found value
     */
    @Override
    protected Object getPropertyInternal(final String key)
    {
<span class="fc" id="L286">        final List&lt;QueryResult&lt;T&gt;&gt; results = fetchNodeList(key);</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (results.isEmpty())</span>
        {
<span class="fc" id="L290">            return null;</span>
        }
<span class="fc" id="L292">        final NodeHandler&lt;T&gt; handler = getModel().getNodeHandler();</span>
<span class="fc" id="L293">        final List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">        for (final QueryResult&lt;T&gt; result : results)</span>
        {
<span class="fc" id="L296">            final Object value = valueFromResult(result, handler);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            if (value != null)</span>
            {
<span class="fc" id="L299">                list.add(value);</span>
            }
<span class="fc" id="L301">        }</span>

<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (list.size() &lt; 1)</span>
        {
<span class="fc" id="L305">            return null;</span>
        }
<span class="fc bfc" id="L307" title="All 2 branches covered.">        return (list.size() == 1) ? list.get(0) : list;</span>
    }

    /**
     * Adds the property with the specified key. This task will be delegated to
     * the associated {@code ExpressionEngine}, so the passed in key
     * must match the requirements of this implementation.
     *
     * @param key the key of the new property
     * @param obj the value of the new property
     */
    @Override
    protected void addPropertyInternal(final String key, final Object obj)
    {
<span class="fc" id="L321">        addPropertyToModel(key, getListDelimiterHandler().parse(obj));</span>
<span class="fc" id="L322">    }</span>

    /**
     * {@inheritDoc} This method is not called in the normal way (via
     * {@code addProperty()} for hierarchical configurations because all values
     * to be added for the property have to be passed to the model in a single
     * step. However, to allow derived classes to add an arbitrary value as an
     * object, a special implementation is provided here. The passed in object
     * is not parsed as a list, but passed directly as only value to the model.
     */
    @Override
    protected void addPropertyDirect(final String key, final Object value)
    {
<span class="fc" id="L335">        addPropertyToModel(key, Collections.singleton(value));</span>
<span class="fc" id="L336">    }</span>

    /**
     * Helper method for executing an add property operation on the model.
     *
     * @param key the key of the new property
     * @param values the values to be added for this property
     */
    private void addPropertyToModel(final String key, final Iterable&lt;?&gt; values)
    {
<span class="fc" id="L346">        getModel().addProperty(key, values, this);</span>
<span class="fc" id="L347">    }</span>

    /**
     * Adds a collection of nodes at the specified position of the configuration
     * tree. This method works similar to {@code addProperty()}, but
     * instead of a single property a whole collection of nodes can be added -
     * and thus complete configuration sub trees. E.g. with this method it is
     * possible to add parts of another {@code BaseHierarchicalConfiguration}
     * object to this object. If the passed in key refers to
     * an existing and unique node, the new nodes are added to this node.
     * Otherwise a new node will be created at the specified position in the
     * hierarchy. Implementation node: This method performs some book-keeping
     * and then delegates to {@code addNodesInternal()}.
     *
     * @param key the key where the nodes are to be added; can be &lt;b&gt;null&lt;/b&gt;,
     * then they are added to the root node
     * @param nodes a collection with the {@code Node} objects to be
     * added
     */
    @Override
    public final void addNodes(final String key, final Collection&lt;? extends T&gt; nodes)
    {
<span class="pc bpc" id="L369" title="1 of 4 branches missed.">        if (nodes == null || nodes.isEmpty())</span>
        {
<span class="fc" id="L371">            return;</span>
        }

<span class="fc" id="L374">        beginWrite(false);</span>
        try
        {
<span class="fc" id="L377">            fireEvent(ConfigurationEvent.ADD_NODES, key, nodes, true);</span>
<span class="fc" id="L378">            addNodesInternal(key, nodes);</span>
<span class="fc" id="L379">            fireEvent(ConfigurationEvent.ADD_NODES, key, nodes, false);</span>
        }
        finally
        {
<span class="fc" id="L383">            endWrite();</span>
<span class="fc" id="L384">        }</span>
<span class="fc" id="L385">    }</span>

    /**
     * Actually adds a collection of new nodes to this configuration. This
     * method is called by {@code addNodes()}. It can be overridden by
     * subclasses that need to adapt this operation.
     *
     * @param key the key where the nodes are to be added; can be &lt;b&gt;null&lt;/b&gt;,
     *        then they are added to the root node
     * @param nodes a collection with the {@code Node} objects to be added
     * @since 2.0
     */
    protected void addNodesInternal(final String key, final Collection&lt;? extends T&gt; nodes)
    {
<span class="fc" id="L399">        getModel().addNodes(key, nodes, this);</span>
<span class="fc" id="L400">    }</span>

    /**
     * Checks if this configuration is empty. Empty means that there are no keys
     * with any values, though there can be some (empty) nodes.
     *
     * @return a flag if this configuration is empty
     */
    @Override
    protected boolean isEmptyInternal()
    {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        return !nodeDefined(getModel().getNodeHandler().getRootNode());</span>
    }

    /**
     * Checks if the specified key is contained in this configuration. Note that
     * for this configuration the term &amp;quot;contained&amp;quot; means that the key
     * has an associated value. If there is a node for this key that has no
     * value but children (either defined or undefined), this method will still
     * return &lt;b&gt;false &lt;/b&gt;.
     *
     * @param key the key to be checked
     * @return a flag if this key is contained in this configuration
     */
    @Override
    protected boolean containsKeyInternal(final String key)
    {
<span class="fc bfc" id="L427" title="All 2 branches covered.">        return getPropertyInternal(key) != null;</span>
    }

    /**
     * Sets the value of the specified property.
     *
     * @param key the key of the property to set
     * @param value the new value of this property
     */
    @Override
    protected void setPropertyInternal(final String key, final Object value)
    {
<span class="fc" id="L439">        getModel().setProperty(key, value, this);</span>
<span class="fc" id="L440">    }</span>

    /**
     * {@inheritDoc} This implementation delegates to the expression engine.
     */
    @Override
    public List&lt;QueryResult&lt;T&gt;&gt; resolveKey(final T root, final String key,
            final NodeHandler&lt;T&gt; handler)
    {
<span class="fc" id="L449">        return getExpressionEngine().query(root, key, handler);</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to {@code resolveKey()} and
     * then filters out attribute results.
     */
    @Override
    public List&lt;T&gt; resolveNodeKey(final T root, final String key, final NodeHandler&lt;T&gt; handler)
    {
<span class="fc" id="L459">        final List&lt;QueryResult&lt;T&gt;&gt; results = resolveKey(root, key, handler);</span>
<span class="fc" id="L460">        final List&lt;T&gt; targetNodes = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (final QueryResult&lt;T&gt; result : results)</span>
        {
<span class="fc bfc" id="L463" title="All 2 branches covered.">            if (!result.isAttributeResult())</span>
            {
<span class="fc" id="L465">                targetNodes.add(result.getNode());</span>
            }
<span class="fc" id="L467">        }</span>
<span class="fc" id="L468">        return targetNodes;</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to the expression engine.
     */
    @Override
    public NodeAddData&lt;T&gt; resolveAddKey(final T root, final String key,
            final NodeHandler&lt;T&gt; handler)
    {
<span class="fc" id="L478">        return getExpressionEngine().prepareAdd(root, key, handler);</span>
    }

    /**
     * {@inheritDoc} This implementation executes a query for the given key and
     * constructs a {@code NodeUpdateData} object based on the results. It
     * determines which nodes need to be changed and whether new ones need to be
     * added or existing ones need to be removed.
     */
    @Override
    public NodeUpdateData&lt;T&gt; resolveUpdateKey(final T root, final String key,
            final Object newValue, final NodeHandler&lt;T&gt; handler)
    {
<span class="fc" id="L491">        final Iterator&lt;QueryResult&lt;T&gt;&gt; itNodes = fetchNodeList(key).iterator();</span>
<span class="fc" id="L492">        final Iterator&lt;?&gt; itValues = getListDelimiterHandler().parse(newValue).iterator();</span>
<span class="fc" id="L493">        final Map&lt;QueryResult&lt;T&gt;, Object&gt; changedValues =</span>
                new HashMap&lt;&gt;();
<span class="fc" id="L495">        Collection&lt;Object&gt; additionalValues = null;</span>
<span class="fc" id="L496">        Collection&lt;QueryResult&lt;T&gt;&gt; removedItems = null;</span>

<span class="fc bfc" id="L498" title="All 4 branches covered.">        while (itNodes.hasNext() &amp;&amp; itValues.hasNext())</span>
        {
<span class="fc" id="L500">            changedValues.put(itNodes.next(), itValues.next());</span>
        }

        // Add additional nodes if necessary
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (itValues.hasNext())</span>
        {
<span class="fc" id="L506">            additionalValues = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">            while (itValues.hasNext())</span>
            {
<span class="fc" id="L509">                additionalValues.add(itValues.next());</span>
            }
        }

        // Remove remaining nodes
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (itNodes.hasNext())</span>
        {
<span class="fc" id="L516">            removedItems = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">            while (itNodes.hasNext())</span>
            {
<span class="fc" id="L519">                removedItems.add(itNodes.next());</span>
            }
        }

<span class="fc" id="L523">        return new NodeUpdateData&lt;&gt;(changedValues, additionalValues,</span>
                removedItems, key);
    }

    /**
     * {@inheritDoc} This implementation uses the expression engine to generate a
     * canonical key for the passed in node. For this purpose, the path to the
     * root node has to be traversed. The cache is used to store and access keys
     * for nodes encountered on the path.
     */
    @Override
    public String nodeKey(final T node, final Map&lt;T, String&gt; cache, final NodeHandler&lt;T&gt; handler)
    {
<span class="fc" id="L536">        final List&lt;T&gt; path = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L537">        T currentNode = node;</span>
<span class="fc" id="L538">        String key = cache.get(node);</span>
<span class="fc bfc" id="L539" title="All 4 branches covered.">        while (key == null &amp;&amp; currentNode != null)</span>
        {
<span class="fc" id="L541">            path.add(0, currentNode);</span>
<span class="fc" id="L542">            currentNode = handler.getParent(currentNode);</span>
<span class="fc" id="L543">            key = cache.get(currentNode);</span>
        }

<span class="fc bfc" id="L546" title="All 2 branches covered.">        for (final T n : path)</span>
        {
<span class="fc" id="L548">            final String currentKey = getExpressionEngine().canonicalKey(n, key, handler);</span>
<span class="fc" id="L549">            cache.put(n, currentKey);</span>
<span class="fc" id="L550">            key = currentKey;</span>
<span class="fc" id="L551">        }</span>

<span class="fc" id="L553">        return key;</span>
    }

    /**
     * Clears this configuration. This is a more efficient implementation than
     * the one inherited from the base class. It delegates to the node model.
     */
    @Override
    protected void clearInternal()
    {
<span class="fc" id="L563">        getModel().clear(this);</span>
<span class="fc" id="L564">    }</span>

    /**
     * Removes all values of the property with the given name and of keys that
     * start with this name. So if there is a property with the key
     * &amp;quot;foo&amp;quot; and a property with the key &amp;quot;foo.bar&amp;quot;, a call
     * of {@code clearTree(&quot;foo&quot;)} would remove both properties.
     *
     * @param key the key of the property to be removed
     */
    @Override
    public final void clearTree(final String key)
    {
<span class="fc" id="L577">        beginWrite(false);</span>
        try
        {
<span class="fc" id="L580">            fireEvent(ConfigurationEvent.CLEAR_TREE, key, null, true);</span>
<span class="fc" id="L581">            final Object nodes = clearTreeInternal(key);</span>
<span class="fc" id="L582">            fireEvent(ConfigurationEvent.CLEAR_TREE, key, nodes, false);</span>
        }
        finally
        {
<span class="pc" id="L586">            endWrite();</span>
<span class="pc" id="L587">        }</span>
<span class="fc" id="L588">    }</span>

    /**
     * Actually clears the tree of elements referenced by the given key. This
     * method is called by {@code clearTree()}. Subclasses that need to adapt
     * this operation can override this method. This base implementation
     * delegates to the node model.
     *
     * @param key the key of the property to be removed
     * @return an object with information about the nodes that have been removed
     *         (this is needed for firing a meaningful event of type
     *         CLEAR_TREE)
     * @since 2.0
     */
    protected Object clearTreeInternal(final String key)
    {
<span class="fc" id="L604">        return getModel().clearTree(key, this);</span>
    }

    /**
     * Removes the property with the given key. Properties with names that start
     * with the given key (i.e. properties below the specified key in the
     * hierarchy) won't be affected. This implementation delegates to the node+
     * model.
     *
     * @param key the key of the property to be removed
     */
    @Override
    protected void clearPropertyDirect(final String key)
    {
<span class="fc" id="L618">        getModel().clearProperty(key, this);</span>
<span class="fc" id="L619">    }</span>

    /**
     * {@inheritDoc} This implementation is slightly more efficient than the
     * default implementation. It does not iterate over the key set, but
     * directly queries its size after it has been constructed. Note that
     * constructing the key set is still an O(n) operation.
     */
    @Override
    protected int sizeInternal()
    {
<span class="fc" id="L630">        return visitDefinedKeys().getKeyList().size();</span>
    }

    /**
     * Returns an iterator with all keys defined in this configuration.
     * Note that the keys returned by this method will not contain any
     * indices. This means that some structure will be lost.
     *
     * @return an iterator with the defined keys in this configuration
     */
    @Override
    protected Iterator&lt;String&gt; getKeysInternal()
    {
<span class="fc" id="L643">        return visitDefinedKeys().getKeyList().iterator();</span>
    }

    /**
     * Creates a {@code DefinedKeysVisitor} and visits all defined keys with it.
     *
     * @return the visitor after all keys have been visited
     */
    private DefinedKeysVisitor visitDefinedKeys()
    {
<span class="fc" id="L653">        final DefinedKeysVisitor visitor = new DefinedKeysVisitor();</span>
<span class="fc" id="L654">        final NodeHandler&lt;T&gt; nodeHandler = getModel().getNodeHandler();</span>
<span class="fc" id="L655">        NodeTreeWalker.INSTANCE.walkDFS(nodeHandler.getRootNode(), visitor,</span>
                nodeHandler);
<span class="fc" id="L657">        return visitor;</span>
    }

    /**
     * Returns an iterator with all keys defined in this configuration that
     * start with the given prefix. The returned keys will not contain any
     * indices. This implementation tries to locate a node whose key is the same
     * as the passed in prefix. Then the subtree of this node is traversed, and
     * the keys of all nodes encountered (including attributes) are added to the
     * result set.
     *
     * @param prefix the prefix of the keys to start with
     * @return an iterator with the found keys
     */
    @Override
    protected Iterator&lt;String&gt; getKeysInternal(final String prefix)
    {
<span class="fc" id="L674">        final DefinedKeysVisitor visitor = new DefinedKeysVisitor(prefix);</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (containsKey(prefix))</span>
        {
            // explicitly add the prefix
<span class="fc" id="L678">            visitor.getKeyList().add(prefix);</span>
        }

<span class="fc" id="L681">        final List&lt;QueryResult&lt;T&gt;&gt; results = fetchNodeList(prefix);</span>
<span class="fc" id="L682">        final NodeHandler&lt;T&gt; handler = getModel().getNodeHandler();</span>

<span class="fc bfc" id="L684" title="All 2 branches covered.">        for (final QueryResult&lt;T&gt; result : results)</span>
        {
<span class="fc bfc" id="L686" title="All 2 branches covered.">            if (!result.isAttributeResult())</span>
            {
<span class="fc bfc" id="L688" title="All 2 branches covered.">                for (final T c : handler.getChildren(result.getNode()))</span>
                {
<span class="fc" id="L690">                    NodeTreeWalker.INSTANCE.walkDFS(c, visitor, handler);</span>
<span class="fc" id="L691">                }</span>
<span class="fc" id="L692">                visitor.handleAttributeKeys(prefix, result.getNode(), handler);</span>
            }
<span class="fc" id="L694">        }</span>

<span class="fc" id="L696">        return visitor.getKeyList().iterator();</span>
    }

    /**
     * Returns the maximum defined index for the given key. This is useful if
     * there are multiple values for this key. They can then be addressed
     * separately by specifying indices from 0 to the return value of this
     * method. If the passed in key is not contained in this configuration,
     * result is -1.
     *
     * @param key the key to be checked
     * @return the maximum defined index for this key
     */
    @Override
    public final int getMaxIndex(final String key)
    {
<span class="fc" id="L712">        beginRead(false);</span>
        try
        {
<span class="fc" id="L715">            return getMaxIndexInternal(key);</span>
        }
        finally
        {
<span class="pc" id="L719">            endRead();</span>
<span class="nc" id="L720">        }</span>
    }

    /**
     * Actually retrieves the maximum defined index for the given key. This
     * method is called by {@code getMaxIndex()}. Subclasses that need to adapt
     * this operation have to override this method.
     *
     * @param key the key to be checked
     * @return the maximum defined index for this key
     * @since 2.0
     */
    protected int getMaxIndexInternal(final String key)
    {
<span class="fc" id="L734">        return fetchNodeList(key).size() - 1;</span>
    }

    /**
     * Creates a copy of this object. This new configuration object will contain
     * copies of all nodes in the same structure. Registered event listeners
     * won't be cloned; so they are not registered at the returned copy.
     *
     * @return the copy
     * @since 1.2
     */
    @Override
    public Object clone()
    {
<span class="fc" id="L748">        beginRead(false);</span>
        try
        {
            @SuppressWarnings(&quot;unchecked&quot;) // clone returns the same type
            final
<span class="fc" id="L753">            AbstractHierarchicalConfiguration&lt;T&gt; copy =</span>
<span class="fc" id="L754">                    (AbstractHierarchicalConfiguration&lt;T&gt;) super.clone();</span>
<span class="fc" id="L755">            copy.setSynchronizer(NoOpSynchronizer.INSTANCE);</span>
<span class="fc" id="L756">            copy.cloneInterpolator(this);</span>
<span class="fc" id="L757">            copy.setSynchronizer(ConfigurationUtils.cloneSynchronizer(getSynchronizer()));</span>
<span class="fc" id="L758">            copy.model = cloneNodeModel();</span>

<span class="fc" id="L760">            return copy;</span>
        }
<span class="nc" id="L762">        catch (final CloneNotSupportedException cex)</span>
        {
            // should not happen
<span class="nc" id="L765">            throw new ConfigurationRuntimeException(cex);</span>
        }
        finally
        {
<span class="pc" id="L769">            endRead();</span>
<span class="nc" id="L770">        }</span>
    }

    /**
     * Creates a clone of the node model. This method is called by
     * {@code clone()}.
     *
     * @return the clone of the {@code NodeModel}
     * @since 2.0
     */
    protected abstract NodeModel&lt;T&gt; cloneNodeModel();

    /**
     * Helper method for resolving the specified key.
     *
     * @param key the key
     * @return a list with all results selected by this key
     */
    protected List&lt;QueryResult&lt;T&gt;&gt; fetchNodeList(final String key)
    {
<span class="fc" id="L790">        final NodeHandler&lt;T&gt; nodeHandler = getModel().getNodeHandler();</span>
<span class="fc" id="L791">        return resolveKey(nodeHandler.getRootNode(), key, nodeHandler);</span>
    }

    /**
     * Checks if the specified node is defined.
     *
     * @param node the node to be checked
     * @return a flag if this node is defined
     */
    protected boolean nodeDefined(final T node)
    {
<span class="fc" id="L802">        final DefinedVisitor&lt;T&gt; visitor = new DefinedVisitor&lt;&gt;();</span>
<span class="fc" id="L803">        NodeTreeWalker.INSTANCE.walkBFS(node, visitor, getModel().getNodeHandler());</span>
<span class="fc" id="L804">        return visitor.isDefined();</span>
    }

    /**
     * Returns the {@code NodeModel} used by this configuration. This method is
     * intended for internal use only. Access to the model is granted without
     * any synchronization. This is in contrast to the &amp;quot;official&amp;quot;
     * {@code getNodeModel()} method which is guarded by the configuration's
     * {@code Synchronizer}.
     *
     * @return the node model
     */
    protected NodeModel&lt;T&gt; getModel()
    {
<span class="fc" id="L818">        return model;</span>
    }

    /**
     * Extracts the value from a query result.
     *
     * @param result the {@code QueryResult}
     * @param handler the {@code NodeHandler}
     * @return the value of this result (may be &lt;b&gt;null&lt;/b&gt;)
     */
    private Object valueFromResult(final QueryResult&lt;T&gt; result, final NodeHandler&lt;T&gt; handler)
    {
<span class="fc bfc" id="L830" title="All 2 branches covered.">        return result.isAttributeResult() ? result.getAttributeValue(handler)</span>
<span class="fc" id="L831">                : handler.getValue(result.getNode());</span>
    }

    /**
     * A specialized visitor that checks if a node is defined.
     * &amp;quot;Defined&amp;quot; in this terms means that the node or at least one of
     * its sub nodes is associated with a value.
     *
     * @param &lt;T&gt; the type of the nodes managed by this hierarchical configuration
     */
<span class="fc" id="L841">    private static class DefinedVisitor&lt;T&gt; extends</span>
            ConfigurationNodeVisitorAdapter&lt;T&gt;
    {
        /** Stores the defined flag. */
        private boolean defined;

        /**
         * Checks if iteration should be stopped. This can be done if the first
         * defined node is found.
         *
         * @return a flag if iteration should be stopped
         */
        @Override
        public boolean terminate()
        {
<span class="fc" id="L856">            return isDefined();</span>
        }

        /**
         * Visits the node. Checks if a value is defined.
         *
         * @param node the actual node
         */
        @Override
        public void visitBeforeChildren(final T node, final NodeHandler&lt;T&gt; handler)
        {
<span class="fc" id="L867">            defined =</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">                    handler.getValue(node) != null</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">                            || !handler.getAttributes(node).isEmpty();</span>
<span class="fc" id="L870">        }</span>

        /**
         * Returns the defined flag.
         *
         * @return the defined flag
         */
        public boolean isDefined()
        {
<span class="fc" id="L879">            return defined;</span>
        }
    }

    /**
     * A specialized visitor that fills a list with keys that are defined in a
     * node hierarchy.
     */
    private class DefinedKeysVisitor extends
            ConfigurationNodeVisitorAdapter&lt;T&gt;
    {
        /** Stores the list to be filled. */
        private final Set&lt;String&gt; keyList;

        /** A stack with the keys of the already processed nodes. */
        private final Stack&lt;String&gt; parentKeys;

        /**
         * Default constructor.
         */
        public DefinedKeysVisitor()
<span class="fc" id="L900">        {</span>
<span class="fc" id="L901">            keyList = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L902">            parentKeys = new Stack&lt;&gt;();</span>
<span class="fc" id="L903">        }</span>

        /**
         * Creates a new {@code DefinedKeysVisitor} instance and sets the
         * prefix for the keys to fetch.
         *
         * @param prefix the prefix
         */
        public DefinedKeysVisitor(final String prefix)
        {
<span class="fc" id="L913">            this();</span>
<span class="fc" id="L914">            parentKeys.push(prefix);</span>
<span class="fc" id="L915">        }</span>

        /**
         * Returns the list with all defined keys.
         *
         * @return the list with the defined keys
         */
        public Set&lt;String&gt; getKeyList()
        {
<span class="fc" id="L924">            return keyList;</span>
        }

        /**
         * {@inheritDoc} This implementation removes this
         * node's key from the stack.
         */
        @Override
        public void visitAfterChildren(final T node, final NodeHandler&lt;T&gt; handler)
        {
<span class="fc" id="L934">            parentKeys.pop();</span>
<span class="fc" id="L935">        }</span>

        /**
         * {@inheritDoc} If this node has a value, its key is added
         * to the internal list.
         */
        @Override
        public void visitBeforeChildren(final T node, final NodeHandler&lt;T&gt; handler)
        {
<span class="fc bfc" id="L944" title="All 2 branches covered.">            final String parentKey = parentKeys.isEmpty() ? null</span>
<span class="fc" id="L945">                    : parentKeys.peek();</span>
<span class="fc" id="L946">            final String key = getExpressionEngine().nodeKey(node, parentKey, handler);</span>
<span class="fc" id="L947">            parentKeys.push(key);</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">            if (handler.getValue(node) != null)</span>
            {
<span class="fc" id="L950">                keyList.add(key);</span>
            }
<span class="fc" id="L952">            handleAttributeKeys(key, node, handler);</span>
<span class="fc" id="L953">        }</span>

        /**
         * Appends all attribute keys of the current node.
         *
         * @param parentKey the parent key
         * @param node the current node
         * @param handler the {@code NodeHandler}
         */
        public void handleAttributeKeys(final String parentKey, final T node,
                final NodeHandler&lt;T&gt; handler)
        {
<span class="fc bfc" id="L965" title="All 2 branches covered.">            for (final String attr : handler.getAttributes(node))</span>
            {
<span class="fc" id="L967">                keyList.add(getExpressionEngine().attributeKey(parentKey, attr));</span>
<span class="fc" id="L968">            }</span>
<span class="fc" id="L969">        }</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L975">        return super.toString() + &quot;(&quot; + getRootElementNameInternal() + &quot;)&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>