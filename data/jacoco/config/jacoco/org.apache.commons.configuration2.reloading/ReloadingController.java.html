<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReloadingController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2.reloading</a> &gt; <span class="el_source">ReloadingController.java</span></div><h1>ReloadingController.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.configuration2.reloading;

import org.apache.commons.configuration2.event.Event;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.event.EventListenerList;
import org.apache.commons.configuration2.event.EventSource;
import org.apache.commons.configuration2.event.EventType;

/**
 * &lt;p&gt;
 * A class for adding support for reload operations in a generic way.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A {@code ReloadingController} monitors a specific source and triggers
 * reloading events if necessary. So it does not perform reloading itself, but
 * only sends out notifications when it thinks that this should be done. This
 * allows for a very generic setup in which different components involved in
 * reloading are loosely coupled via events.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A typical usage scenario is as follows:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;A {@code ReloadingController} instance is created and initialized with a
 * {@link ReloadingDetector} object.&lt;/li&gt;
 * &lt;li&gt;A number of {@link EventListener} objects for reloading events can be
 * registered at the controller.&lt;/li&gt;
 * &lt;li&gt;Now the controller's {@code checkForReloading()} method is called
 * whenever a check is to be performed. This could be done for instance by a
 * timer in regular intervals or by any other means appropriate for a specific
 * application.&lt;/li&gt;
 * &lt;li&gt;When a check reveals that a reload operation is necessary all registered
 * event listeners are notified.&lt;/li&gt;
 * &lt;li&gt;Typically one of the listeners is responsible to perform the actual
 * reload operation. (How this is done is not in the scope of the controller
 * object.) After this has been done, the controller's
 * {@code resetReloadingState()} method must be called. It tells the controller
 * that the last notification has been processed and that new checks are
 * possible again. It is important that this method is called. Otherwise,
 * {@code checkForReloading()} will not do any new checks or send out event
 * notifications any more.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * This class can be accessed from multiple threads concurrently. It shields the
 * associated {@link ReloadingDetector} object for concurrent access, so that a
 * concrete detector implementation does not have to be thread-safe.
 * &lt;/p&gt;
 *
 * @version $Id$
 * @since 2.0
 */
public class ReloadingController implements EventSource
{
    /** Stores a reference to the reloading detector. */
    private final ReloadingDetector detector;

    /** The helper object which manages the registered event listeners. */
    private final EventListenerList listeners;

    /** A flag whether this controller is in reloading state. */
    private boolean reloadingState;

    /**
     * Creates a new instance of {@code ReloadingController} and associates it
     * with the given {@code ReloadingDetector} object.
     *
     * @param detect the {@code ReloadingDetector} (must not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the detector is undefined
     */
    public ReloadingController(final ReloadingDetector detect)
<span class="fc" id="L87">    {</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (detect == null)</span>
        {
<span class="fc" id="L90">            throw new IllegalArgumentException(</span>
                    &quot;ReloadingDetector must not be null!&quot;);
        }

<span class="fc" id="L94">        detector = detect;</span>
<span class="fc" id="L95">        listeners = new EventListenerList();</span>
<span class="fc" id="L96">    }</span>

    /**
     * Returns the {@code ReloadingDetector} used by this controller.
     *
     * @return the {@code ReloadingDetector}
     */
    public ReloadingDetector getDetector()
    {
<span class="fc" id="L105">        return detector;</span>
    }

    /**
     * {@inheritDoc} This class generates events of type {@code ReloadingEvent}.
     */
    @Override
    public &lt;T extends Event&gt; void addEventListener(
            final EventType&lt;T&gt; eventType, final EventListener&lt;? super T&gt; listener)
    {
<span class="fc" id="L115">        listeners.addEventListener(eventType, listener);</span>
<span class="fc" id="L116">    }</span>

    @Override
    public &lt;T extends Event&gt; boolean removeEventListener(
            final EventType&lt;T&gt; eventType, final EventListener&lt;? super T&gt; listener)
    {
<span class="fc" id="L122">        return listeners.removeEventListener(eventType, listener);</span>
    }

    /**
     * Tests whether this controller is in &lt;em&gt;reloading state&lt;/em&gt;. A return
     * value of &lt;b&gt;true&lt;/b&gt; means that a previous invocation of
     * {@code checkForReloading()} has detected the necessity for a reload
     * operation, but {@code resetReloadingState()} has not been called yet. In
     * this state no further reloading checks are possible.
     *
     * @return a flag whether this controller is in reloading state
     */
    public synchronized boolean isInReloadingState()
    {
<span class="fc" id="L136">        return reloadingState;</span>
    }

    /**
     * Performs a check whether a reload operation is necessary. This method has
     * to be called to trigger the generation of reloading events. It delegates
     * to the associated {@link ReloadingDetector} and sends out notifications
     * if necessary. The argument can be an arbitrary data object; it will be
     * part of the event notification sent out when a reload operation should be
     * performed. The return value indicates whether a change was detected and
     * an event was sent. Once a need for a reload is detected, this controller
     * is in &lt;em&gt;reloading state&lt;/em&gt;. Until this state is reset (by calling
     * {@link #resetReloadingState()}), no further reloading checks are
     * performed by this method, and no events are fired; it then returns always
     * &lt;b&gt;true&lt;/b&gt;.
     *
     * @param data additional data for an event notification
     * @return a flag whether a reload operation is necessary
     */
    public boolean checkForReloading(final Object data)
    {
<span class="fc" id="L157">        boolean sendEvent = false;</span>
<span class="fc" id="L158">        synchronized (this)</span>
        {
<span class="fc bfc" id="L160" title="All 2 branches covered.">            if (isInReloadingState())</span>
            {
<span class="fc" id="L162">                return true;</span>
            }
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (getDetector().isReloadingRequired())</span>
            {
<span class="fc" id="L166">                sendEvent = true;</span>
<span class="fc" id="L167">                reloadingState = true;</span>
            }
<span class="pc" id="L169">        }</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (sendEvent)</span>
        {
<span class="fc" id="L173">            listeners.fire(new ReloadingEvent(this, data));</span>
<span class="fc" id="L174">            return true;</span>
        }
<span class="fc" id="L176">        return false;</span>
    }

    /**
     * Resets the reloading state. This tells the controller that reloading has
     * been performed and new checks are possible again. If this controller is
     * not in reloading state, this method has no effect.
     */
    public synchronized void resetReloadingState()
    {
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (isInReloadingState())</span>
        {
<span class="fc" id="L188">            getDetector().reloadingPerformed();</span>
<span class="fc" id="L189">            reloadingState = false;</span>
        }
<span class="fc" id="L191">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>